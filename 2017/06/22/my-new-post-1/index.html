<!doctype html>



  


<html class="theme-next muse use-motion" lang="">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="About iOS Collection Views（关于Collection Views）collection view 是一种运用灵活多变的布局展示一系列有序数据的途径。通常，collection view的使用使用像网格状排列来呈现数据，但是iOS中的collection view 的能力不仅限于行和列。使用collection views, 视觉元素的精确布局可通过子类化定义并被动态改变。">
<meta property="og:type" content="article">
<meta property="og:title" content="Collection View Programming Guide for iOS">
<meta property="og:url" content="http://yoursite.com/2017/06/22/my-new-post-1/index.html">
<meta property="og:site_name" content="David的技术小站">
<meta property="og:description" content="About iOS Collection Views（关于Collection Views）collection view 是一种运用灵活多变的布局展示一系列有序数据的途径。通常，collection view的使用使用像网格状排列来呈现数据，但是iOS中的collection view 的能力不仅限于行和列。使用collection views, 视觉元素的精确布局可通过子类化定义并被动态改变。">
<meta property="og:image" content="http://orzup79vr.bkt.clouddn.com/UICollectionView_Programming_01.png">
<meta property="og:image" content="http://orzup79vr.bkt.clouddn.com/UICollectionView_Programming_02.png">
<meta property="og:image" content="http://orzup79vr.bkt.clouddn.com/UICollectionView_Programming_03.png">
<meta property="og:image" content="http://orzup79vr.bkt.clouddn.com/UICollectionView_Programming_04.png">
<meta property="og:image" content="http://orzup79vr.bkt.clouddn.com/UICollectionView_Programming_05.jpg">
<meta property="og:image" content="http://orzup79vr.bkt.clouddn.com/UICollectionView_Programming_06.png">
<meta property="og:image" content="http://orzup79vr.bkt.clouddn.com/UICollectionView_Programming_07.png">
<meta property="og:image" content="http://orzup79vr.bkt.clouddn.com/UICollectionView_Programming_08.png">
<meta property="og:image" content="http://orzup79vr.bkt.clouddn.com/UICollectionView_Programming_09.png">
<meta property="og:image" content="http://orzup79vr.bkt.clouddn.com/UICollectionView_Programming_10.png">
<meta property="og:image" content="http://orzup79vr.bkt.clouddn.com/UICollectionView_Programming_11.png">
<meta property="og:updated_time" content="2017-07-27T07:29:36.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Collection View Programming Guide for iOS">
<meta name="twitter:description" content="About iOS Collection Views（关于Collection Views）collection view 是一种运用灵活多变的布局展示一系列有序数据的途径。通常，collection view的使用使用像网格状排列来呈现数据，但是iOS中的collection view 的能力不仅限于行和列。使用collection views, 视觉元素的精确布局可通过子类化定义并被动态改变。">
<meta name="twitter:image" content="http://orzup79vr.bkt.clouddn.com/UICollectionView_Programming_01.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/06/22/my-new-post-1/"/>





  <title>Collection View Programming Guide for iOS | David的技术小站</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">David的技术小站</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archiv
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/22/my-new-post-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="David">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="David的技术小站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Collection View Programming Guide for iOS</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">David</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2017-06-22T17:45:52+08:00">
                2017-06-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="About-iOS-Collection-Views（关于Collection-Views）"><a href="#About-iOS-Collection-Views（关于Collection-Views）" class="headerlink" title="About iOS Collection Views（关于Collection Views）"></a>About iOS Collection Views（关于Collection Views）</h2><p>collection view 是一种运用灵活多变的布局展示一系列有序数据的途径。通常，collection view的使用使用像网格状排列来呈现数据，但是iOS中的collection view 的能力不仅限于行和列。使用collection views, 视觉元素的精确布局可通过子类化定义并被动态改变。所以你可以实现网格，栈，圆形布局，动态改变布局，或任何你可以想象的排列布局。</p>
<p>Collection views 严格分离被呈现的数据和用来呈现这些数据的视觉元素。应用程序只负责管理这些数据，以及提供用来呈现这些数据的视图对象。然后collection view接手这些视图，并完成所有的工作把数据定位在屏幕上。它和一个布局对象(layout object)联合工作，布局对象的工作是指定视图的位置和可视化属性,该布局对象也可以通过子类化来实现你特定的需求。因此，你提供数据，布局对象提供位置信息，collection view 把这两部分结合起来呈现最后的外观。</p>
<h3 id="At-a-Glance-概览"><a href="#At-a-Glance-概览" class="headerlink" title="At a Glance(概览)"></a>At a Glance(概览)</h3><p>标准的iOS collection view 类提供了实现简单网格的所有行为(behavior)。你也可以扩展标准类来支持自定义布局，用于特定的交互。</p>
<h3 id="A-Collection-View-Manages-the-Visual-Presentation-of-Data-Driven-Views（管理驱动视图的可视化数据呈现）"><a href="#A-Collection-View-Manages-the-Visual-Presentation-of-Data-Driven-Views（管理驱动视图的可视化数据呈现）" class="headerlink" title="A Collection View Manages the Visual Presentation of Data-Driven Views（管理驱动视图的可视化数据呈现）"></a>A Collection View Manages the Visual Presentation of Data-Driven Views（管理驱动视图的可视化数据呈现）</h3><p>collection view为你的数据相关的视图展示提供了便利。collection view 的唯一关注点是接手你的视图并以特定的方式把它们布局到屏幕上。collection view 关注的是视图的呈现和排列，而不是它们的内容。为了在应用里使用collection view, 理解collection view, 层对象，以及你的自定义对象之间的交互是至关重要的。</p>
<h3 id="The-Flow-Layout-Supports-Grids-and-Other-Line-Oriented-Presentations-流式布局支持网格和其它面向线条的表现方式"><a href="#The-Flow-Layout-Supports-Grids-and-Other-Line-Oriented-Presentations-流式布局支持网格和其它面向线条的表现方式" class="headerlink" title="The Flow Layout Supports Grids and Other Line-Oriented Presentations(流式布局支持网格和其它面向线条的表现方式)"></a>The Flow Layout Supports Grids and Other Line-Oriented Presentations(流式布局支持网格和其它面向线条的表现方式)</h3><p>流式布局(flow layout)是UIKit提供的一个具体布局对象。 通常你使用它来实现网格—就是，数据项的行和列—但是流布局还支持任何类型的线性流。因为它不仅限于网格，你可以使用它来为你的内容创建各种有趣复杂的排列，既可以子类化它也可以直接使用。 流布局支持不同尺寸的数据项， 项的间距可变，可以自定义页头(header)和页脚(footer), 已经无需子类化就可以定制页边空白(margin)。 子类化能让你更进一步的调整流布局类的行为。</p>
<p>个人经验：在实际开发过程中，大多数情况是直接使用Flow Layout布局或者是继承Flow Layout布局，所以，理解该对象如何使用是至关重要的。</p>
<h3 id="Gesture-Recognizers-Can-Be-Used-for-Cell-and-Layout-Manipulations-手势识别能用于单元-cell-和布局操作"><a href="#Gesture-Recognizers-Can-Be-Used-for-Cell-and-Layout-Manipulations-手势识别能用于单元-cell-和布局操作" class="headerlink" title="Gesture Recognizers Can Be Used for Cell and Layout Manipulations(手势识别能用于单元(cell)和布局操作)"></a>Gesture Recognizers Can Be Used for Cell and Layout Manipulations(手势识别能用于单元(cell)和布局操作)</h3><p>就像所有视图一样，你可以在collection view里采用手势识别来操作视图的内容。因为collection view 涉及了多个视图的协作， 在collection view 里结合手势识别能有助于理解一些基本技术。你可以在collection view里调整(tweak)布局属性或操作数据项。</p>
<h3 id="Custom-Layouts-Let-You-Go-Beyond-Grids-自定义布局让你超越网格布局"><a href="#Custom-Layouts-Let-You-Go-Beyond-Grids-自定义布局让你超越网格布局" class="headerlink" title="Custom Layouts Let You Go Beyond Grids(自定义布局让你超越网格布局)"></a>Custom Layouts Let You Go Beyond Grids(自定义布局让你超越网格布局)</h3><p>基本的布局对象能被子类化来实现应用程序里的自定义布局。 在大多数情况下，自定义布局不需要大量的的代码。 然而，它能帮助你理解布局是如何工作的，那样你就能设计高效的布局对象。<br>Relevant chapter: “Creating Custom Layouts”</p>
<h2 id="Collection-View-Basics-Collection-View基础"><a href="#Collection-View-Basics-Collection-View基础" class="headerlink" title="Collection View Basics(Collection View基础)"></a>Collection View Basics(Collection View基础)</h2><p>为了让它的内容显示在屏幕上，collection view联合了多个不同了的对象。一些对象是自定义并且必须是由应用程序提供的。 比如，你的应用程序必须提供一个数据源对象，它告诉collection view有多少内容需要显示。 其它对象则由UIKit提供，是基本collection view设计的一部分。</p>
<p>就像表格一样，collection views 是面向数据的对象，它们的实现都涉及到与应用程序对象的合作(collaboration)。理解你必须在你的代码里做什么，需要一点背景信息—关于一个collection view如何完成它想做的工作。</p>
<h3 id="Collection-View-is-a-Collaboration-of-Objects-Collection-View-是一些对象的合作结果"><a href="#Collection-View-is-a-Collaboration-of-Objects-Collection-View-是一些对象的合作结果" class="headerlink" title="Collection View is a Collaboration of Objects(Collection View 是一些对象的合作结果)"></a>Collection View is a Collaboration of Objects(Collection View 是一些对象的合作结果)</h3><p>collection view的设计把要显示的内容从数据排列方式中分离，并显示到屏幕上。应用程序严格负责管理要显示的数据，但是多个不同对象管理数据的视觉呈现。 表1-1 列出了在UIKit里的collection view 类并根据它们在实现一个colletion view界面中所扮演的角色来组织它们。大多数类都被设计能直接使用，不需要子类化，所以你常常可以用很少的代码就可以实现一个collection view。 当在你想要实现超出所提供的行为时，你可以子类化并提供那个行为。</p>
<p>图1-1 显示了跟collection view与跟它相关联的内核对象之间的关系。 collection view从它的数据源获取将要显示的单元格(cells)信息. 应用程序提供自定义的数据源和委托对象，它们用来管理包含选区 和 突出显示的单元格等所有内容。布局对象负责决定那些单元格属于哪里，并把那信息以一个或多个布局属性对象的方式发送给collection view. 然后collection view 用实际单元格(以及其他视图)合并这些布局信息来创建最后的可视化呈现。<br><img src="http://orzup79vr.bkt.clouddn.com/UICollectionView_Programming_01.png"></p>
<p>当你创建一个collection view界面时，第一件事是添加一个UICollectionView对象到你的故事板(storyboard)或nib文件。你可以把collection view想象成中央枢纽(central hub)，所有其它对象从这里出发。添加完成后，你可以开始配置任何相关对象，比如数据源或委托。 但是所有的配置都是围绕collection view本身。 比如，没有collection view，你不会创建一个布局对象。</p>
<h3 id="Reusable-Views-Improve-Performance-复用视图提高性能"><a href="#Reusable-Views-Improve-Performance-复用视图提高性能" class="headerlink" title="Reusable Views Improve Performance(复用视图提高性能)"></a>Reusable Views Improve Performance(复用视图提高性能)</h3><p>Collection views采用了一个视图回收程序来提高效率。 当视图离开屏幕时，它们实际上是从collection view移除并被放入了一个可重复使用的队列当中，而不是被删除。随着新内容在屏幕上被滚动，显示的视图从队列中移出并重新添加新的内容。 为了促进该回收和重复利用，所有collection view展示的视图都必须继承自UICollectionReusableView类。<br>Collection views 支持3种不同类型的可重复利用的视图，每一种都有一个特定的使用目的，</p>
<ul>
<li>Cells显示collection view主要内容的单元格。一个单元格的工作是显示一项从数据源对象那获取的内容。 每个单元格都必须是UICollectionViewCell类的一个实例，你可能根据需要成为它的子类来呈现你的内容。单元格对象提供了管理它们自己的选区 和 高亮状态(highlight state)的内在支持。</li>
<li>Supplementary views (补充视图)显示一个section的相关信息。 就像单元格一样，补充视图也是数据驱动的。 然而，补充视图是可选的，它们的用途和位置由所使用的布局对象控制。 比如，流布局支持页眉和页脚作为可选补充视图。</li>
<li>Decoration views(装饰视图)完全是布局对象所有的可视化装饰，并且不被绑定到数据源对象中的任何数据。比如，一个布局对象可能使用装饰视图来实现一个自定义背景。</li>
</ul>
<p>跟表格视图不同，collection views 不在数据源提供单元格和补充视图上强加一个特殊风格。基本的可重复利用视图类都是你可以修改的空白画布。你可以使用它们来建立小型视图层次结构，显示图像，或如果你想甚至可以动态绘制内容。</p>
<p>你的数据源对象负责提供单元格和补充视图，以供相关的collection view使用。 然而，数据源绝不会直接创建视图。 当被请求一个视图时，你的数据源使用collection view提供的方法从队列中取出所需类型的一个视图。从队列取出过程永远返回一个有效的视图，不管是从一个可重复使用队列里检索一个或是通过一个类，nib 文件或你提供的故事板来创建一个新视图。</p>
<h3 id="The-Layout-Object-Controls-the-Visual-Presentation-布局对象管理可视化外形"><a href="#The-Layout-Object-Controls-the-Visual-Presentation-布局对象管理可视化外形" class="headerlink" title="The Layout Object Controls the Visual Presentation(布局对象管理可视化外形)"></a>The Layout Object Controls the Visual Presentation(布局对象管理可视化外形)</h3><p>布局对象独自负责决定collection view中的元素的位置和可视化风格。 尽管你的数据源对象提供了视图和实际内容，但是布局对象决定了那些视图的尺寸，位置，以及其他跟外形相关的各种属性。 该责任的分离让动态改变布局而不改变应用程序管理的任何数据对象成为可能。(比如淘宝，转转等app在展示搜索结果的时候可以很方便的切换布局)</p>
<p>collection view使用的布局过程跟应用程序视图的其它部分使用的布局过程有关，但是又不同于应用程序其它部分使用的布局过程。换句话说，不要困惑一个布局对象用layoutSubviews方法做了什么，该方法在一个父视图里被用于重新定位子视图。一个布局对象绝不会操作它直接管理的那些视图，因为它实际上并不拥有那些视图。相反，它产生描述collection view中单元格，补充视图，以及装饰视图的位置，尺寸以及可视化外形的各种属性。然后，由collection view 来把这些属性应用到实际的视图对象中。</p>
<p>实际上没有限制布局对象如何影响collection view中的视图。一个布局对象可以移动一些视图，其它对象不可以。它可以移动视图一点点或它能随机的在屏幕上移动它们。它甚至不需要留意周围的视图就可以让视图重新定位。 比如，如果它想，它可以把视图一个接着一个把视图堆起来。唯一的限制是布局对象如何影响应用程序想要的视觉风格。</p>
<p>下图显示了一个垂直滚动的流布局如何安排它的单元格和补充视图。在一个垂直滚动流布局里，内容区的宽度固定，高度自由调整以容纳内容。 为了计算区域，布局对象一次只放置一个视图和单元格， 为每个视图和单元格选择最合适的位置。在流布局的情况中，单元格和补充视图的尺寸是在布局对象中或使用一个委托，把尺寸作为属性被指定。计算布局只是使用那些属性来放置每个视图的一个问题。</p>
<p><img src="http://orzup79vr.bkt.clouddn.com/UICollectionView_Programming_02.png"></p>
<p>布局对象控制不仅仅控制它们视图的尺寸和位置。 布局对象能指定其他视图相关的各种属性，比如它的透明度，它在3D空间里的变换，以及它是在其它视图的上面还是下面可见。这些属性让布局对象创建更多的有趣布局。 比如，你可以通过把视图一个接一个放在另一视图的上面形成单元格堆栈，改变它们的z顺序(UICollectionViewLayoutAttributes中的zIndex属性)，或使用一个变换让它们在任何轴上旋转。</p>
<h3 id="Collection-Views-Initiate-Animations-Automatically-Collection-views自动初始化动画"><a href="#Collection-Views-Initiate-Animations-Automatically-Collection-views自动初始化动画" class="headerlink" title="Collection Views Initiate Animations Automatically(Collection views自动初始化动画)"></a>Collection Views Initiate Animations Automatically(Collection views自动初始化动画)</h3><p>Collection views 在基础层上建立了对动画的支持。 当你插入或删除数据项(items)或sections时，collection view 自动动画任何受变更影响的视图。比如，当你插入一个数据项，插入位置后面的所有数据项通常都得往后移动，给新数据项腾出位置。collection view知道如何创建这些动画，因为它知道数据项的当前位置，并能从插入点开始计算它们的最后位置。 因此，它能用动画展示每个数据项从初始位置到结束位置的变化。</p>
<p>除了动画插入，删除以及移动操作，你还可以在任何时候让布局无效并强制它重新绘制它的内容。无效化布局不能直接动画数据项；当你无效化布局时，collection view在它们已经计算好的新位置显示数据项，不需要动画。然而，无效化布局操作导致布局对象明确地移动数据项。 在一个自定义布局内，你可以使用该行为来定期定位单元格，并创建一个动画效果。</p>
<h2 id="Designing-Your-Data-Source-and-Delegate-设计你的数据源和委托"><a href="#Designing-Your-Data-Source-and-Delegate-设计你的数据源和委托" class="headerlink" title="Designing Your Data Source and Delegate(设计你的数据源和委托)"></a>Designing Your Data Source and Delegate(设计你的数据源和委托)</h2><p>每个collection view都必须有一个提供显示内容的数据源对象。 数据源对象是应用程序提供的对象。它可以是应用程序的数据模型中获得的对象，也可以是管理collection view的视图控制器。数据源的唯一要求是它必须能给collection view提供所需的信息，比如当collection view显示数据项时，需要知道的数据项和所需视图的总数量等。</p>
<p>委托对象是一个可选(但推荐)的对象，它管理所要显示内容的部分相关外形以及跟内容交互等各个方面。 委托的主要工作是管理单元格的highlighting和selection. 然而，委托也能被扩展来提供额外的信息。比如，流布局扩展基本的委托行为来自定义布局标准(layout metrics)，比如单元格尺寸和单元格之间的间距。</p>
<h3 id="The-Data-Source-Manages-Your-Content-数据源管理内容"><a href="#The-Data-Source-Manages-Your-Content-数据源管理内容" class="headerlink" title="The Data Source Manages Your Content(数据源管理内容)"></a>The Data Source Manages Your Content(数据源管理内容)</h3><p>数据源对象负责管理你想使用collection view显示的内容。数据源对象必须遵守UICollectionViewDataSource协议，该协议定义了基本行为以及你必须实现的方法。数据源的工作是给collection view提供以下问题的答案:</p>
<ul>
<li>collection view 包含了几个section？</li>
<li>每个section里有几项数据内容？</li>
<li>对于每个section 或 数据项， 该用什么视图来显示相关的内容？</li>
</ul>
<p>Sections(段)和items(项)是collection view内容的基本组织原则。一个collection view通常至少有一个段。每个段包含0个或多个数据项。数据项代表你想要显示的内容，段把那些数据项组织成逻辑组。比如，一个照片应用程序可能使用不同的段来代表一个照片相册或是按同一天拍摄分组的一些照片集。<br>collection view的引用数据包含它使用的NSIndexPath 对象。 当你想要定位一个数据项时，collection view使用布局对象提供给它的索引路径信息。 对于数据项，索引路径包含了一个段号和一个项目号。 对于补充视图，索引路径包含布局对象提供的那个值。</p>
<p>不管你如何排列数据对象的段和数据项，那些段和数据项最终的可视化呈现任然由布局对象决定。不同的布局对象可以呈现出完全不同的段和项数据，正如图2-1中所示。 在图中，流布局对象垂直排列每个段。自定义布局可以不在直线上放置这些段，再次证明布局和实际数据的分离。</p>
<p><img src="http://orzup79vr.bkt.clouddn.com/UICollectionView_Programming_03.png"><br>￼</p>
<h3 id="Designing-Your-Data-Objects-设计你的数据对象"><a href="#Designing-Your-Data-Objects-设计你的数据对象" class="headerlink" title="Designing Your Data Objects(设计你的数据对象)"></a>Designing Your Data Objects(设计你的数据对象)</h3><p>一个高效的数据源使用段和数据项来帮助组织它的后台数据对象。 把数据组织进段和数据项让实现你的数据源方法更加容易。并且因为你的数据源方法会被经常调用，所以你想要确保你对这些方法的实现能够尽可能快的检索数据。</p>
<p>一个简单的解决办法(但肯定不是唯一的解决办法)是让数据源使用一个嵌套的数组集，正如图2-2中所示。 在该配置中，一个高层次的数组包含了一个或多个数组，这些被包含的数组代表你的数据源段。然后每个段数组包含了那个段的所有数据项。在段里查找一个数据项是检索它的段数组，然后从该数组检索那个数据项。 该排列方式类型很适合用来管理中等规模的项目集合，也很适合用来根据需要检索单个数据项。</p>
<p><img src="http://orzup79vr.bkt.clouddn.com/UICollectionView_Programming_04.png"><br>￼<br>When designing your data structures, you can always start with a simple set of arrays and move to a more efficient structure as needed. In general, your data objects should never be a performance bottleneck. The collection view usually accesses your data source only when it needs to know how many objects there are in total and when it needs views for elements that are currently onscreen. However, if the layout object relies on data from your data objects, performance could be severely impacted when the data source contains thousands of objects. For this reason, you should avoid implementing custom layout objects that rely on data from your data source. Instead, you should design your layout objects to lay out content independently from your data objects.<br>当你设计你的数据结构时，你可以总是以一个简单的数据集开始，然后根据需要把它移入更有效地结构中。 通常，你的数据对象绝不应该是一个性能瓶颈。 collection view通常只在它需要的时候才访问你的数据源：1. 需要知道总共有多少数据对象的时候，2. 需要为当前在屏幕上的元素(elements)提供视图的时候. 然而，如果布局对象依赖数据对象中的数据，当数据源包含成千上万的对象时，性能就会受到很大的影响。由于这个原因，你应该避免实现依赖数据源数据的自定义布局对象。相反，你应该设计和数据对象相分离的布局对象。</p>
<h3 id="Telling-the-Collection-View-About-Your-Content-告诉Collection-View你的内容"><a href="#Telling-the-Collection-View-About-Your-Content-告诉Collection-View你的内容" class="headerlink" title="Telling the Collection View About Your Content(告诉Collection View你的内容)"></a>Telling the Collection View About Your Content(告诉Collection View你的内容)</h3><p>Among the questions asked of your data source by the collection view are how many sections it contains and how many items each section contains. The collection view asks your data source to provide this information when any of the following actions occur:<br>在collection view询问数据源的问题当中，有数据源包含多少段以及每个段包含多少数据项的问题。 collection view要求数据源在以下情况发生时提供这些信息给它：</p>
<ul>
<li>collection view显示第一次显示。</li>
<li>你给collection view分配了一个不同的数据源对象。</li>
<li>你明确地调用了collection view的reloadData。</li>
<li>collection view委托对象使用performBatchUpdates:completion:方法执行一个block以及任意的insert，move和delete方法。</li>
</ul>
<p>你使用 numberOfSectionsInCollectionView: 方法提供段的数量，使用collectionView:numberOfItemsInSection: 方法来提供每段的项目数量。你必须实现collectionView:numberOfItemsInSection:方法，但是如果你只有一个段，numberOfSectionsInCollectionView:方法的实现是可选的。两个方法都返回一个整数值，代表合适的信息。</p>
<p>如果你实现上图那样的数据源，你的数据源实现方法可能和下面代码那样简单。data 变量是数据源的一个自定义成员变量，它存储了段的高层数组。 获取数组的数目产生段的数目。 获取其中一个子数组的数目产生段中的数据项数量。(当然，你应该在代码中完成任何需要的错误检测来确保返回的值是有效的)</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">NSInteger</span>)numberOfSectionsInCollectionView:(<span class="built_in">UICollectionView</span>*)collectionView &#123;</div><div class="line">    <span class="comment">// _data is a class member variable that contains one array per section.</span></div><div class="line">    <span class="keyword">return</span> [_data count];</div><div class="line">&#125;</div><div class="line"> </div><div class="line">- (<span class="built_in">NSInteger</span>)collectionView:(<span class="built_in">UICollectionView</span>*)collectionView numberOfItemsInSection:(<span class="built_in">NSInteger</span>)section &#123;</div><div class="line">    <span class="built_in">NSArray</span>* sectionArray = [_data objectAtIndex:section];</div><div class="line">    <span class="keyword">return</span> [sectionArray count];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Configuring-Cells-and-Supplementary-Views-配置单元格和补充视图"><a href="#Configuring-Cells-and-Supplementary-Views-配置单元格和补充视图" class="headerlink" title="Configuring Cells and Supplementary Views(配置单元格和补充视图)"></a>Configuring Cells and Supplementary Views(配置单元格和补充视图)</h3><p>数据源的另一个重要任务是提供collection view用来显示内容的各种视图。collection view完全不知道关于应用程序内容的任何信息。它只是简单的获取你提供给它的视图，并对这些视图应用当前的布局信息。因此，提供视图显示的任何东西都是你的责任。</p>
<p>当数据源报告完段和数据项的数量之后，collection view要求布局对象为collection view的内容提供布局的元素(UICollectionViewLayoutAttributes) 在一些时候，collection view要求布局对象提供一个指定矩形(常常是可视但不需要的矩形)中的元素列表。collection view 使用该列表要求你的数据源提供相关的单元格和补充视图。为了提供那些单元格和补充视图，你的代码必须完成以下工作：</p>
<ul>
<li>在你的故事板文件里嵌入你的单元格模板和视图。(或者，为每种类型的单元格或视图注册一个类或nib文件。</li>
<li>被请求时，在数据源里取回并配置相应的单元格或视图。</li>
</ul>
<p>为了确保单元格和补充视图以最有效的方式被应用，collection view承担了为你创建那些对象的责任。 每个collection view维护了当前不使用的单元格和补充视图的内容队列。 你不需要自己创建那些对象，当你需要视图时，你只需要向collection view要求相应的视图即可。 如果一个请求正在一个可重用队列中等待，collection view准备一个视图并快速地返回给你。因此，每次你取回一个单元格或视图时，你得到的总是可以马上就可以用的对象。</p>
<p>重用标识符让注册多种类型的单元格和多种类型的补充视图成为可能。重用标识符是一个字符串，用来辨别你注册的单元格和视图类型。字符串的内容只跟你的数据源对象有关。但是当被请求一个视图或单元格时，你可以根据提供的索引路径来决定你想要哪种类型的视图或单元格，然后给获取方法传递合适的重用标识符。</p>
<h3 id="Registering-Your-Cells-and-Supplementary-Views-注册你的单元格和补充视图"><a href="#Registering-Your-Cells-and-Supplementary-Views-注册你的单元格和补充视图" class="headerlink" title="Registering Your Cells and Supplementary Views(注册你的单元格和补充视图)"></a>Registering Your Cells and Supplementary Views(注册你的单元格和补充视图)</h3><p>你可以使用代码或者storyboard来配置collection view的单元格和视图。</p>
<p>当你在stoyboard里配置单元格和补充视图时，你通过往collection view里拖拉item来完成，并在那里配置它。 这样做就给collection view和相应的单元格和视图创建了一个对应关系。</p>
<ul>
<li>对于单元格，从对象库(object library)里拖拉一个Collection View Cell, 放在你的collection view里。设置单元格的自定义类和collection 可重用视图标识符。</li>
<li>对于补充视图，从对象库里拖拉一个Collection Reusable View，并把它放在collection view里。 设置视图的自定义类和collection可重用视图标识符。</li>
</ul>
<p>要想通过代码配置单元格，使用registerClass:forCellWithReuseIdentifier:或registerNib:forCellWithReuseIdentifier:方法来关联单元格和一个重用标识符。你可以在父视图控制器初始化进程中作为一部分调用这些方法。</p>
<p>要想通过程序配置补充视图，使用registerClass:forSupplementaryViewOfKind:withReuseIdentifier:或registerNib:forSupplementaryViewOfKind:withReuseIdentifier:方法来关联每个视图和重用标识符。你可以在父视图控制器的初始化进程里作为一部分调用这些方法。</p>
<p>尽管你只是用一个重用标识符注册所有单元格，但是补充视图要求一个额外指定的标识符–被称为种类字符串(kind string)。 每个布局对象负责定义它支持的补充视图的种类(kinds)。 比如， UICollectionViewFlowLayout 类支持两种类型的补充视图：section header和section footer。 所以它定义了UICollectionElementKindSectionHeader 和 UICollectionElementKindSectionFooter 两个常量来区分这两种类型的视图。 布局期间，布局对象包含了该类型字符串以及该视图类型的其它布局属性。然后collection view 让这些信息随着你的数据源一起传递。 你的数据源然后使用类型字符串和重用标识符来决定取回哪个视图对象。<br>Note: If you implement your own custom layouts, you are responsible for defining the kinds of supplementary views your layout supports. A layout may support any number of supplementary views, each with its own kind string. For more information about defining custom layouts, see “Creating Custom Layouts.”</p>
<p>注意：如果你实现你自定义的布局，由你负责为你的补充视图定义它支持的种类。 一个布局可能支持任何数量的补充视图，它们每个都有自己的类型字符串。关于定义自定义布局的更多信息，请看 “Creating Custom Layouts.”</p>
<p>注册是一个一次性事件，你必须在尝试获取任何单元格或视图之前完成它。一旦完成注册，你就可以根据需要获取单元格或视图，而不需要重新注册它们。不推荐在获取一个或多个数据项之后更改注册信息。只注册一次单元格和视图，并使用它完成工作是更好的选择。</p>
<h3 id="Dequeueing-and-Configuring-Cells-and-Views-出队和配置单元格和视图"><a href="#Dequeueing-and-Configuring-Cells-and-Views-出队和配置单元格和视图" class="headerlink" title="Dequeueing and Configuring Cells and Views(出队和配置单元格和视图)"></a>Dequeueing and Configuring Cells and Views(出队和配置单元格和视图)</h3><p>出队进程(dequeueing process)的设计是为了减轻你自己创建一个单元格或视图的必要。只要你之前注册了一个单元格或视图，dequeue方法就绝对不会返回nil值。如果在一个重用队列里没有给定类型的单元格或视图，dequeue方法会使用你的storyboard或使用你注册的类或nib文件简单创建一个。</p>
<p>你从出队进程中返回的单元格应该已经在初始状态并准备好配置新数据。对于必须被创建的单元格或视图，出队进程通过正常过程来创建并初始化它—换句话说，就是通过从一个故事板或nib文件载入或通过创建并用initWithFrame:方法初始化来获取一个新实例。但是，如果数据项不是从头开始创建，而是从一个重用队列里取回的，则可能已经包含了上一次使用返回的数据。 在这种情况下，dequeue方法调用数据项的prepareForReuse方法来让它返回自身以进入初始状态。当你实现一个自定义单元格或视图类时，你可以重载该方法并使用它来重新设置属性到默认值，并执行任何额外的清除工作。</p>
<p>当视图完成出队之后，所有的数据源必须做的是用它的新数据配置视图。 你可以使用传递给数据源方法的索引路径来定位相应的数据对象，并给该对象应用新值。 配置完视图之后，从你的方法中返回视图。下面显示了一个如何配置一个单元格的例子。 单元格完成出队之后，方法用单元格的位置信息设置单元格的自定义标签并返回该单元格。</p>
<p>配置一个自定义的cell<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">UICollectionViewCell</span> *)collectionView:(<span class="built_in">UICollectionView</span> *)collectionView</div><div class="line">                  cellForItemAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</div><div class="line">   MyCustomCell* newCell = [<span class="keyword">self</span>.collectionView dequeueReusableCellWithReuseIdentifier:MyCellID</div><div class="line">                                                                          forIndexPath:indexPath];</div><div class="line"> </div><div class="line">   newCell.cellLabel.text = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"Section:%d, Item:%d"</span>, indexPath.section, indexPath.item];</div><div class="line">   <span class="keyword">return</span> newCell;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Inserting-Deleting-and-Moving-Sections-and-Items-插入，删除，以及移动Sections-和-Items"><a href="#Inserting-Deleting-and-Moving-Sections-and-Items-插入，删除，以及移动Sections-和-Items" class="headerlink" title="Inserting, Deleting, and Moving Sections and Items(插入，删除，以及移动Sections 和 Items)"></a>Inserting, Deleting, and Moving Sections and Items(插入，删除，以及移动Sections 和 Items)</h3><p>要想插入，删除或移动单个section 或 item, 你必须跟随这些步骤：</p>
<ul>
<li>在你的数据资源对象里更新数据</li>
<li>调用collection view相应的方法来插入或删除section 或 item.</li>
</ul>
<p>在通知collection view任何更改之前更新你的数据源是至关重要的。collection view方法假设你的数据源包含了当前正确的数据。如果它没有包含，collection view可能从你的数据源接收到错误的数据项集或请求并不存在的数据项从而导致应用程序崩溃。</p>
<p>当你添加，删除或移动一个数据项时，collection view的方法自动创建动画来反映这些改变。 如果你想一起动画多个改变，你必须在一个块里执行所有的插入，删除或移动操作，并把该块传递给performBatchUpdates:completion: 方法。然后批量更新过程同时动画所有的改变，你可以在同一个块里自由的混合调用插入，删除，或移动数据项操作。</p>
<p>以下代码显示了一个简单例子，关于如何执行一个删除当前被选择数据项的批量更新。被传递到 performBatchUpdates:completion: 方法的块首先调用一个自定义方法来更新数据源。 然后它高数collection view删除这些数据项。 你提供的更新块和完成块都是同步执行的，尽管它们自己的动画是由系统在一个后台线程里被执行。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Listing <span class="number">2</span><span class="number">-3</span>  Deleting the selected items</div><div class="line">[<span class="keyword">self</span>.collectionView performBatchUpdates:^&#123;</div><div class="line">   <span class="built_in">NSArray</span>* itemPaths = [<span class="keyword">self</span>.collectionView indexPathsForSelectedItems];</div><div class="line"> </div><div class="line">   <span class="comment">// Delete the items from the data source.</span></div><div class="line">   [<span class="keyword">self</span> deleteItemsFromDataSourceAtIndexPaths:itemPaths];</div><div class="line"> </div><div class="line">   <span class="comment">// Now delete the items from the collection view.</span></div><div class="line">   [<span class="keyword">self</span>.collectionView deleteItemsAtIndexPaths:tempArray];</div><div class="line">&#125; completion:<span class="literal">nil</span>];</div></pre></td></tr></table></figure></p>
<h3 id="Managing-the-Visual-State-for-Selections-and-Highlights-管理选区和高亮显示的视觉状态"><a href="#Managing-the-Visual-State-for-Selections-and-Highlights-管理选区和高亮显示的视觉状态" class="headerlink" title="Managing the Visual State for Selections and Highlights(管理选区和高亮显示的视觉状态)"></a>Managing the Visual State for Selections and Highlights(管理选区和高亮显示的视觉状态)</h3><p>Collection views默认支持单项选择(single-item selection)， 它们能被配置成支持多项选择或多项取消选择。 collection view 侦测在它边界里的轻击(taps)，并相应的选择或高亮相关单元格。对于大部分情况，collection view只修改一个单元格的属性来声明该单元格已被选择或高亮；它不改变所有单元格的视觉外形，只有一种情况例外。如果一个单元格的selectedBackgroundView 属性有一个有效视图，当单元格被高亮后选择，collection view显示那个视图。</p>
<p>下列代码可以用在你自定义cell中，用于展示highlighted和selected状态的展示。当cell第一次加载，不再highlighted和selected状态的时候，cell的backgroundview会是默认的值。当cell处于highlighted和selected状态时，selectedBackgroundView属性会替代background属性展示。在这种情况下，当cell处于selected或者highlighted状态时，cell的背景色从白色变为红色。<br>设置背景视图来展示改变的状态<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIView</span>* backgroundView = [[<span class="built_in">UIView</span> alloc] initWithFrame:<span class="keyword">self</span>.bounds];</div><div class="line">backgroundView.backgroundColor = [<span class="built_in">UIColor</span> redColor];</div><div class="line"><span class="keyword">self</span>.backgroundView = backgroundView;</div><div class="line"></div><div class="line"><span class="built_in">UIView</span>* selectedBGView = [[<span class="built_in">UIView</span> alloc] initWithFrame:<span class="keyword">self</span>.bounds];</div><div class="line">selectedBGView.backgroundColor = [<span class="built_in">UIColor</span> whiteColor];</div><div class="line"><span class="keyword">self</span>.selectedBackgroundView = selectedBGView;</div></pre></td></tr></table></figure></p>
<p><img src="http://orzup79vr.bkt.clouddn.com/UICollectionView_Programming_05.jpg">        UICollectionViewCell<br>                                                                                    backgroundView<br>                                                                                selectedBackgroundView<br>                                                                          contentView</p>
<p>collection view的委托提供了一下方法来方便highlighting 和 selecting<br>  collectionView:shouldSelectItemAtIndexPath:<br>  collectionView:shouldDeselectItemAtIndexPath:<br>  collectionView:didSelectItemAtIndexPath:<br>  collectionView:didDeselectItemAtIndexPath:<br>  collectionView:shouldHighlightItemAtIndexPath:<br>  collectionView:didHighlightItemAtIndexPath:<br>  collectionView:didUnhighlightItemAtIndexPath:</p>
<p>这些方法可以让你为了特定的情况改变highlighting/selecting行为。</p>
<p>比如，当你倾向于自己展示selection状态，你可以让selectedBackgroundView为nil，使用委托来生成外观的改变。比如你可以在 collectionView:didSelectItemAtIndexPath::方法中展示视图的外观改变，在collectionView:didDeselectItemAtIndexPath: 中复原。</p>
<p>一个cell的短暂highlight<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)collectionView:(<span class="built_in">UICollectionView</span> *)colView didHighlightItemAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</div><div class="line">    <span class="built_in">UICollectionViewCell</span>* cell = [colView cellForItemAtIndexPath:indexPath];</div><div class="line">    cell.contentView.backgroundColor = [<span class="built_in">UIColor</span> blueColor];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)collectionView:(<span class="built_in">UICollectionView</span> *)colView didUnhighlightItemAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath &#123;</div><div class="line">    <span class="built_in">UICollectionViewCell</span>* cell = [colView cellForItemAtIndexPath:indexPath];</div><div class="line">    cell.contentView.backgroundColor = <span class="literal">nil</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>一个单元格的高亮状态和被选择状态之间有一个微妙但是很重要的区别。高亮状态是一个过渡状态，当用户的手指还触摸在设备屏幕上时，你可以使用它来给单元格应用视觉高亮效果。只有当collection view一直在单元格上追踪触摸事件时，该状态被设置为YES. 当触摸结束时，高亮状态恢复到NO。 相反，被选择状态只在一些列的触摸事件结束以后才改变—特别是，当这些触摸事件表明用户试着选择该单元格时。</p>
<p>下图演示了当用户触摸一个未被选择单元格时发生的一些列步骤。 初始触摸down事件导致collection view改变单元格的高亮状态为YES， 尽管这样做并不自动改变单元格的外形。 如果最后的触摸up事件在单元格里发生，高亮状态回到NO，collection view 把被选择状态设置为YES。 改变被选择状态确实导致collection view在单元格的selectedBackgroundView属性影响下显示视图， 但是这是collection view对单元格做的唯一视觉改变。 其它任何视觉改变都必须由你的委托对象来完成。</p>
<p><img src="http://orzup79vr.bkt.clouddn.com/UICollectionView_Programming_06.png"></p>
<p>当用户选择或取消选择一个单元格时，单元格的被选择状态永远是最后被改变的。单元格里的轻击事件永远导致单元格的高亮状态首先被改变。 只有当轻击序列都结束时，并且任何在那个序列被应用的高效都没移除之后，被选择状态才被改变。 当你设计你的单元格时，你应该确保你的高亮可视化外形跟被选择状态不会以意想不到方式发生冲突。</p>
<h3 id="Showing-the-Edit-Menu-for-a-Cell-为单元格显示编辑按钮"><a href="#Showing-the-Edit-Menu-for-a-Cell-为单元格显示编辑按钮" class="headerlink" title="Showing the Edit Menu for a Cell(为单元格显示编辑按钮)"></a>Showing the Edit Menu for a Cell(为单元格显示编辑按钮)</h3><p>当用户在一个单元格上执行一个长事件轻触手势时，collection view尝试给那个单元格显示一个编辑按钮。 编辑按钮可以被用来在collection view里剪切，拷贝，以及粘贴单元格。在编辑按钮被显示之前，一些情况肯定会出现:</p>
<ul>
<li>collectionView:shouldShowMenuForItemAtIndexPath:</li>
<li>collectionView:canPerformAction:forItemAtIndexPath:withSender:</li>
<li>collectionView:performAction:forItemAtIndexPath:withSender:</li>
<li>collectionView:shouldShowMenuForItemAtIndexPath: 方法必须为所指示的单元格返回YES.</li>
<li>collectionView:canPerformAction:forItemAtIndexPath:withSender: 方法必须至少为一个所需的动作返回YES。 collection view支持以下动作：</li>
<li>cut:</li>
<li>copy:</li>
<li>paste:</li>
</ul>
<p>如果遇到这些问题，用户从按钮选择了一个操作，collection view调用委托的collectionView:performAction:forItemAtIndexPath:withSender: 来执行所指示数据项上的操作。</p>
<p>下列显示了如何防止菜单项之一出现。在该例子中，collectionView:canPerformAction:forItemAtIndexPath:withSender: 方法阻止剪切按钮出现在编辑菜单里。 编辑菜单允许拷贝和粘贴数据项，所以用户能够插入内容。</p>
<p>Selectively disabling actions in the Edit menu(选择性的禁用编辑菜单里的动作)<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)collectionView:(<span class="built_in">UICollectionView</span> *)collectionView</div><div class="line">        canPerformAction:(SEL)action</div><div class="line">        forItemAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</div><div class="line">        withSender:(<span class="keyword">id</span>)sender &#123;</div><div class="line">   <span class="comment">// Support only copying nad pasting of cells.</span></div><div class="line">   <span class="keyword">if</span> ([<span class="built_in">NSStringFromSelector</span>(action) isEqualToString:<span class="string">@"copy:"</span>]</div><div class="line">      || [<span class="built_in">NSStringFromSelector</span>(action) isEqualToString:<span class="string">@"paste:"</span>])</div><div class="line">      <span class="keyword">return</span> <span class="literal">YES</span>;</div><div class="line"> </div><div class="line">   <span class="comment">// Prevent all other actions.</span></div><div class="line">   <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Transition-Between-Layouts-布局间的过渡"><a href="#Transition-Between-Layouts-布局间的过渡" class="headerlink" title="Transition Between Layouts(布局间的过渡)"></a>Transition Between Layouts(布局间的过渡)</h3><p>布局过渡最好的途径就是使用setCollectionViewLayout:animated:方法，但是，如果你需要控制布局过渡或者想使他们相互影响，使用 UICollectionViewTransitionLayout对象</p>
<h2 id="Using-the-Flow-Layout-使用流式布局"><a href="#Using-the-Flow-Layout-使用流式布局" class="headerlink" title="Using the Flow Layout(使用流式布局)"></a>Using the Flow Layout(使用流式布局)</h2><p>UICollectionViewFlowLayout 类是一个具体的布局对象，你可以在你的collection视图里用来组织数据项。 流布局实现一个基于行的分段布局，就是说布局对象位于一个线性路径的单元格内，并且沿着这条线尽可能多的放置单元格。 当它超出当前线得空间时，它创建一个新线并在那里继续布局过程。下图显示了一个垂直滚动的一个流布局。在该例子中，所有行都从上到下水平排列。每个section里的单元格都可以选择性的添加节头(section header)和节尾视图。<br><img src="http://orzup79vr.bkt.clouddn.com/UICollectionView_Programming_07.png"></p>
<p>你可以使用流布局来实现网格，但也可以用它实现更多。一个线性布局可以被应用到很多不同的设计。比如，代替把所有数据项排列成网格，你可以调整间距来把数据项都排列在一个沿着滚动维度(scrolling dimension)的单一直线。数据项可以有不同的尺寸，它比传统网格更加不对称，但是它任然有一个线性流。 流布局有很多可能性。<br>你既可以通过程序也可以使用Xcode里的界面生成器来配置流布局。配置流布局的步骤如下：</p>
<ul>
<li>创建一个流布局对象并把它分配给你的collection view.</li>
<li>配置单元格的宽和高</li>
<li>根据需要设置行和数据项的间距选项</li>
<li>如果你需要节头或节尾，指定它们的尺寸</li>
<li>设置布局的滚动方向<br>重要提示：你必须指定单元格的最小宽和高。如果你没有指定，数据项的高宽默认被指定为0，它们不可见。</li>
</ul>
<h3 id="Customizing-the-Flow-Layout-Attributes-自定义流布局属性"><a href="#Customizing-the-Flow-Layout-Attributes-自定义流布局属性" class="headerlink" title="Customizing the Flow Layout Attributes(自定义流布局属性)"></a>Customizing the Flow Layout Attributes(自定义流布局属性)</h3><p>流布局对象有多个属性用来配置内容的外观。当你设置完成时，这些属性被均匀地应用于布局的所有数据项。 比如，用流布局的itemSize 属性来设置单元格尺寸，导致所有单元格拥有相同的尺寸。</p>
<p>如果你想要动态变化数据项的间距和尺寸，你可以使用UICollectionViewDelegateFlowLayout协议中的方法来实现。你可以在分配给collection view自身的同一个委托对象里实现这些方法。如果实现了其中的一个方法，流布局对象调用该方法代替使用它有的固定值。 然后实现方法为collection view中的所有数据项返回适当的值。</p>
<h3 id="Specifying-the-Size-of-Items-in-the-Flow-Layout-在流布局里指定数据项的尺寸"><a href="#Specifying-the-Size-of-Items-in-the-Flow-Layout-在流布局里指定数据项的尺寸" class="headerlink" title="Specifying the Size of Items in the Flow Layout(在流布局里指定数据项的尺寸)"></a>Specifying the Size of Items in the Flow Layout(在流布局里指定数据项的尺寸)</h3><p>如果所有在collection view里的数据项都有相同尺寸，可以使用流布局对象的itemSize 属性来分配适当的宽和高。(恰当来指定数据项的尺寸) 如果尺寸不发生改变，这是配置布局对象内容的最快捷方式。</p>
<p>如果你想要为单元格指定不同的尺寸，你必须在collection view委托里实现collectionView:layout:sizeForItemAtIndexPath: 方法。你可以使用提供的索引路径信息来返回相关数据项的尺寸。 布局期间，流布局对象把数据项放置在同一行的中间，如下图所示。 行的整体高或宽然后由那个维度中最大的数据项决定。<br><img src="http://orzup79vr.bkt.clouddn.com/UICollectionView_Programming_08.png"><br>￼<br>注意： 当你为单元格指定不同尺寸时，单行上的数据项数目能从一行变换到另一行。</p>
<h3 id="Specifying-the-Space-Between-Items-and-Lines-指定数据项之间，行之间的间隔"><a href="#Specifying-the-Space-Between-Items-and-Lines-指定数据项之间，行之间的间隔" class="headerlink" title="Specifying the Space Between Items and Lines(指定数据项之间，行之间的间隔)"></a>Specifying the Space Between Items and Lines(指定数据项之间，行之间的间隔)</h3><p>流布局允许你指定同一行中数据项的最小间距，以及所有行之间的最小间距。但是你提供的间距只是最小间距。因为根据流布局如何布置它的内容，它可能加大数据项之间的间距，设置一个比你指定的值更大的值。布局对象也可能在数据项被以不同尺寸布置时增加实际行之间的间距。</p>
<p>在布局期间，流布局对象在当前行添加数据项直到没有足够的剩余空间来容纳一整个数据项。如果行正好可以容纳整数个数据项没有空余，那么数据项之间的间隔就等于最小间隔。然而，如果在行尾有多余的空间，布局对象就会增加数据项之间的间隔直到数据项在边界线内均匀分布，正下图所示。 增加间隔提高了数据项的整体外观，防止在每行行尾出现大空白。</p>
<p><img src="http://orzup79vr.bkt.clouddn.com/UICollectionView_Programming_09.png"></p>
<p>对于行间距，流布局对象使用跟数据项间距相同的技术。如果所有的数据项都是一样的尺寸，流布局就能够完全尊重最小行间距，所有数据项就能一行行均匀地被显示。然而，如果数据项有不同的尺寸，每个数据项之间的实际间隔就能变化。</p>
<p>下图显示了当数据项们有不同尺寸时最小行间距发生了什么。在例中，流布局对象从每行挑选在滚动方向上尺寸最大的那个数据项，它在每行里查找有最大高度的那个数据项。 然后它把那些数据项之间的间距设置为最小值。 如果这些数据项位于行的不同部分，正如图中所示，就会导致显示的实际行间距大于最小值。</p>
<p><img src="http://orzup79vr.bkt.clouddn.com/UICollectionView_Programming_10.png"></p>
<p>正如流布局的其它属性，你可以使用固定的间距值或动态改变这些值。行以及数据项间距是一节一节处理的。因此，行间距和数据项间距在一个给定的节里是所有数据项都一样的，但是在节与节之间可能发生变化。你可以使用流间距对象的minimumLineSpacing 和minimumInteritemSpacing属性静态地设置间距，也可以使用collection view委托的collectionView:layout:minimumLineSpacingForSectionAtIndex:和collectionView:layout:minimumInteritemSpacingForSectionAtIndex:方法来设置。</p>
<h3 id="Using-Section-Insets-to-Tweak-the-Margins-of-Your-Content-使用Section-Insets来调整内容的边距"><a href="#Using-Section-Insets-to-Tweak-the-Margins-of-Your-Content-使用Section-Insets来调整内容的边距" class="headerlink" title="Using Section Insets to Tweak the Margins of Your Content(使用Section Insets来调整内容的边距)"></a>Using Section Insets to Tweak the Margins of Your Content(使用Section Insets来调整内容的边距)</h3><p>Section insets是布置单元格时调整有效间距的一种方法。 你可以使用insets在一个节头视图之后在节脚之前插入间距。你还可以使用它们在绕着内容的边插入间距。下图显示insets在一个垂直滚动流布局里如何影响一些内容。</p>
<p><img src="http://orzup79vr.bkt.clouddn.com/UICollectionView_Programming_11.png"> ￼</p>
<p>因为insets减少布局单元格的有效空间总数，你可以使用它们来限制一个给定行里单元格的数目。在一个非滚动方向上指定insets是为每行压缩空间的一种方法。 如果你把那个信息跟一个适当的单元格尺寸相结合，你可以控制每行的单元格数量。</p>
<h3 id="Knowing-When-to-Subclass-the-Flow-Layout-了解何时子类化流布局"><a href="#Knowing-When-to-Subclass-the-Flow-Layout-了解何时子类化流布局" class="headerlink" title="Knowing When to Subclass the Flow Layout(了解何时子类化流布局)"></a>Knowing When to Subclass the Flow Layout(了解何时子类化流布局)</h3><p>尽管你不需要子类化流布局就可以很有效地使用它，但是任然有很多时候想实现需要通过子类化才能获得的行为。表3-1 列出了需要子类化UICollectionViewFlowLayout来达到期望效果的各种场景。</p>
<p>需要子类化 UICollectionViewFlowLayout 的场景<br>|Scenario                              |    Subclassing tips    |<br>| :——–                            | :——–    |<br>|添加新的supplementary或者decoration view|  标准的flow layout中一个section支持一个header和一个footer，没有decoration视图，为了支持另外的supplementary和decoration           |<br>|                                      |  最少要重写以下方法|<br>|                                      |   layoutAttributesForElementsInRect: (required)                                                       |<br>|                                      |   layoutAttributesForItemAtIndexPath: (required)                       |<br>|                                      |   layoutAttributesForSupplementaryViewOfKind:atIndexPath: (to support new supplementary views)                       |<br>|                                      |  layoutAttributesForDecorationViewOfKind:atIndexPath: (to support new decoration views)                        |<br>|                                      |  在layoutAttributesForElementsInRect:方法中，你可以调用super来获取cell的layout attributes然后在特定的矩形范围内为新的|<br>|                                       |supplementary和decoration添加新的attributes，然后用其他方法来提供需要的attributes      |<br>|                                       |在layout中提供view的attributes，查看Creating Layout Attributes和Providing Layout Attributes for Items in a Given Rectangle |<br>|你想修改flow layout返回的layout attributes|重载 layoutAttributesForElementsInRect: 方法以及任何返回布局属性的各种方法。 方法的实现中，你应该调用super, 修改父类提供的属性，然后返|<br>|                                       |回它们|<br>|你想为cell和view增加新的layout attributes| 创建一个自定义 UICollectionViewLayoutAttributes 子类，以及添加你需要用来呈现自定义布局信息的任何属性。|<br>|                                        |子类化 UICollectionViewFlowLayout ，重载layoutAttributesClass 方法。在方法的实现中，返回自定义子类。|<br>|                                        |你还应该重载layoutAttributesForElementsInRect: 方法，layoutAttributesForItemAtIndexPath: 方法，以及任何其它返回布局属性的方法。| ||                                         在自定义实现中，你应该为你定义的任何自定义属性设置值。|<br>|你想指定被插入和删除的元素的起始位置和结束位置|默认时，即将被插入或删除的数据项都将创建一个简单的渐变动画。要想创建自定义动画，你必须重载一些或全部以下方法：|<br>||initialLayoutAttributesForAppearingItemAtIndexPath:|</p>
<p>||initialLayoutAttributesForAppearingSupplementaryElementOfKind:atIndexPath:|</p>
<p>||initialLayoutAttributesForAppearingDecorationElementOfKind:atIndexPath:|</p>
<p>||finalLayoutAttributesForDisappearingItemAtIndexPath:|</p>
<p>||finalLayoutAttributesForDisappearingSupplementaryElementOfKind:atIndexPath:|</p>
<p>||finalLayoutAttributesForDisappearingDecorationElementOfKind:atIndexPath:|</p>
<p>||在这些方法的实现中，在每个视图被插入之前或它们被删除之后为它们指定各种属性。流布局对象使用你提供的属性来动画插入和删除。|</p>
<p>||如果你重载这些方法，你最好也重载prepareForCollectionViewUpdates: 和                                        finalizeCollectionViewUpdates 方法。你可以使用这些方法来追踪当前周期期间哪个数据项将被插入或删除。|</p>
<p>||关于如何实现插入和删除工作的信息，请看Making Insertion and Deletion Animations More Interesting.”|</p>
<p>当然你可以从头开始创建自定义的布局，在你决定做这件事前，花时间思考下这是否是必要的。流式布局提供了许多可自定义的行为，这适用于很多不同种类的布局。流式布局是系统提供给你的，它容易使用且有许多优化，很高效。但是，这并不意味着你不应该自定义布局，流式布局限制了往一个方向滚，如果你的layout包含了，那么自定义的布局是有意义去实现的。如果你的布局不是网格状或是基于线条的布局，或者你布局中的元素频繁的移动，类化流式布局自定义一个布局比子更加复杂。</p>
<p>创建自定义布局，请看Creating Custom Layouts</p>
<h2 id="Incorporating-Gesture-Support-结合手势支持"><a href="#Incorporating-Gesture-Support-结合手势支持" class="headerlink" title="Incorporating Gesture Support(结合手势支持)"></a>Incorporating Gesture Support(结合手势支持)</h2><p>你可以通过使用手势识别给collection 视图添加更大的交互性(interactivity)。跟任何视图一样，你可以给一个collection 视图添加手势识别，当那些手势发生时可以用它来触发各种操作。collection 视图有两种类型的操作是你可能想要实现的，它们是:</p>
<ul>
<li>你想要触发collection 视图的布局信息改变.</li>
<li>你想要直接操作单元格(cells)和视图.</li>
</ul>
<p>你应该总是给collection 视图本身添加(attach)手势识别，而不是给某个特定的cell 或视图。UICollectionView 类是UIScrollView 类的一个子类(descendant). 把手势识别添加到collection 视图不太可能会妨碍其它必须被跟踪(tracked)的各种手势。另外， 因为collection 视图已经访问了你的数据源和布局对象，你还可以访问了你需要相应地(appropriately)操作cells 和视图的所有的信息。</p>
<h3 id="Using-a-Gesture-Recognizer-to-Modify-Layout-Information-使用手势识别来修改布局信息"><a href="#Using-a-Gesture-Recognizer-to-Modify-Layout-Information-使用手势识别来修改布局信息" class="headerlink" title="Using a Gesture Recognizer to Modify Layout Information(使用手势识别来修改布局信息)"></a>Using a Gesture Recognizer to Modify Layout Information(使用手势识别来修改布局信息)</h3><p>手势识别给动态修改布局参数提供一条简单的方法。 比如， 你可能使用一个捏合(pinch)手势识别来改变一个自定义布局上数据项之间的距离。配置这样一个手势识别相对比较简单:</p>
<ul>
<li>创建手势识别</li>
<li>给collection 视图添加手势识别</li>
<li>使用手势识别的处理方法来更新布局参数以及无效化布局对象。</li>
</ul>
<p>创建一个手势识别跟所有对象一样都是alloc/init 过程。 初始化时，你指定目标对象和当手势触发时要调用的操作方法。然后调用collection 视图的addGestureRecognizer: 方法来把它添加到视图。 大部分的实际工作发生在初始化时你指定的操作方法中。</p>
<p>下面显示了一个操作方法例子，该方法由一个collection 视图中的捏合手势识别(pinch gesture recognizer)调用。 在该例子中， 捏合(pinch)数据被用于改变一个自定义布局上cells之间的距离。 该布局对象实现了自定义 updateSpreadDistance 方法，它激活新的距离值并保存它以便在以后的布局过程中使用。操作方法然后无效化布局并强制布局根据新值更新数据项的位置。</p>
<p>Using a gesture recognizer to change layout values(使用一个手势识别来改变布局变量值)<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)handlePinchGesture:(<span class="built_in">UIPinchGestureRecognizer</span> *)sender &#123;</div><div class="line">    <span class="keyword">if</span> ([sender numberOfTouches] != <span class="number">2</span>)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line"> </div><div class="line">   <span class="comment">// Get the pinch points.</span></div><div class="line">   <span class="built_in">CGPoint</span> p1 = [sender locationOfTouch:<span class="number">0</span> inView:[<span class="keyword">self</span> collectionView]];</div><div class="line">   <span class="built_in">CGPoint</span> p2 = [sender locationOfTouch:<span class="number">1</span> inView:[<span class="keyword">self</span> collectionView]];</div><div class="line"> </div><div class="line">   <span class="comment">// Compute the new spread distance.</span></div><div class="line">    <span class="built_in">CGFloat</span> xd = p1.x - p2.x;</div><div class="line">    <span class="built_in">CGFloat</span> yd = p1.y - p2.y;</div><div class="line">    <span class="built_in">CGFloat</span> distance = sqrt(xd*xd + yd*yd);</div><div class="line"> </div><div class="line">   <span class="comment">// Update the custom layout parameter and invalidate.</span></div><div class="line">   MyCustomLayout* myLayout = (MyCustomLayout*)[[<span class="keyword">self</span> collectionView] collectionViewLayout];</div><div class="line">   [myLayout updateSpreadDistance:distance];</div><div class="line">   [myLayout invalidateLayout];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Working-with-the-Default-Gesture-Recognizers-用默认手势识别工作"><a href="#Working-with-the-Default-Gesture-Recognizers-用默认手势识别工作" class="headerlink" title="Working with the Default Gesture Recognizers(用默认手势识别工作)"></a>Working with the Default Gesture Recognizers(用默认手势识别工作)</h3><p>UICollectionView监听单次点击用于初始化它的委托中的highlighting和selecting，如果你想添加自定义的tap或者long-press手势，设置手势识别的值不同于collection view所拥有的。比如，你可能配置一个tap手势为两次点击。</p>
<p>Listing 4-2 shows how you might make the collection view respond to your gesture instead of listening for cell selection/highlighting. Because the collection view does not use a gesture recognizer to initiate its delegate methods, your custom gesture recognizer gets priority over the default selection listeners by delaying the registering of other touch events by setting the delaysTouchesBegan property of your gesture recognizer to YES or cancelling touch events by setting the cancelsTouchesInView property of your gesture recognizer to YES. Whenever a tap is registered, it will first check to see if your gesture recognizer should have priority or not. If the input is not valid for your gesture recognizer, then the delegate methods will be called as normal.</p>
<p>Prioritizing your gesture recognizer<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UITapGestureRecognizer</span>* tapGesture = [[<span class="built_in">UITapGestureRecognizer</span> alloc] initWithTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(handleTapGesture:)];</div><div class="line">tapGesture.delaysTouchesBegan = <span class="literal">YES</span>;</div><div class="line">tapGesture.numberOfTapsRequired = <span class="number">2</span>;</div><div class="line">[<span class="keyword">self</span>.collectionView addGestureRecognizer:tapGesture];</div></pre></td></tr></table></figure></p>
<h3 id="Manipulating-Cells-and-Views-操作Cells-和视图"><a href="#Manipulating-Cells-and-Views-操作Cells-和视图" class="headerlink" title="Manipulating Cells and Views(操作Cells 和视图)"></a>Manipulating Cells and Views(操作Cells 和视图)</h3><p>如何使用一个手势识别来操作cells 和视图依赖于你计划做的操作的类型。 简单的插入和删除可以在一个标准手势识别的操作方法内执行。 但是如果你计划更复杂的操作，你可能需要定义一个自定义手势识别来跟踪你自己的触摸事件。</p>
<p>一种要求一个自定义手势识别的操作类型是把collection视图中的一个cell 从一个位置移到另一个位置。 把一个cell 从collection 视图上(暂时)删除的最直接方法是使用手势识别来拖动该cell拖到一个可视化替代，然后当触摸事件结束时把该cell插入它的新位置。 所有这些操作都要求管理自身的触摸事件，和布局对象紧密工作来决定新的插入位置，操作数据源的改变，然后把数据线插入新位置。</p>
<p>关于创建自定义手势识别的更多信息，请看 Event Handling Guide for iOS.</p>
<h2 id="Creating-Custom-Layouts"><a href="#Creating-Custom-Layouts" class="headerlink" title="Creating Custom Layouts"></a>Creating Custom Layouts</h2><p>Creating Custom Layouts<br> 创建自定义布局<br>Before you start building custom layouts, consider whether doing so is really necessary. The UICollectionViewFlowLayout class provides a significant amount of behavior that has already been optimized for efficiency and that can be adapted in several ways to achieve many different types of standard layouts. The only times to consider implementing a custom layout are in the following situations:<br>在你开始构建自定义布局前，先考虑一下这样做是否真的有必要。UICollectionViewFlowLayout 类已经提供了一系列显著量的特性(behavior)，它们已经优化了效率，并且能够被以不同的方式采用以实现不同类型的标准布局。 只有在以下情况才需要考虑实现一个自定义布局：</p>
<ul>
<li>The layout you want looks nothing like a grid or a line-based breaking layout (a layout in which items are placed into a row until it’s full, then continue on to the next line until all items are placed) or necessitates scrolling in more than one direction.</li>
<li>如果你想要的布局一点也不像网格或是一个行分割的布局(一种布局，其所有数据项都以行的方式放置直到一行填满，然后开始填充下一行直到所有数据项都被放置完成)，或者布局必须在多个方向上滚动。</li>
<li>You want to change all of the cell positions frequently enough that it would be more work to modify the existing flow layout than to create a custom layout.</li>
<li>如果你想要经常改变所有单元格的位置，修改现有的流动布局比创建一个自定义布局麻烦。</li>
<li>The good news is that, from an API perspective, implementing a custom layout is not difficult. The hardest part is performing the calculations needed to determine the positions of items in the layout. When you know the locations of those items, providing that information to the collection view is straightforward.<br>好消息是，从一个API角度(perspective)上看，实现一个自定义布局并不困难。 最难部分是执行各种算法来决定数据项在布局中的位置。 当你知道了那些数据项的位置之后，把这些信息直接提供给集合视图(collection view)。</li>
</ul>
<p>Subclassing UICollectionViewLayout<br>一、子类化UICollectionViewLayout<br>For custom layouts, you want to subclass UICollectionViewLayout, which provides you with a fresh starting point for your design. Only a handful of methods provide the core behavior for your layout object and are required in your implementation. The rest of the methods are there for you to override as needed to tweak the layout behavior. The core methods handle the following crucial tasks:<br>对于自定义布局，你想要子类化UICollectionViewLayout，它为你的设计提供一个崭新的起点。 只有极少数的提供你的布局对象的核心特性行为(behavior)的方法是需要你自己实现。其它方法则只需要你根据需要重写它们来稍稍调整(tweak)布局行为即可。核心方法处理以下关键任务:</p>
<ul>
<li>Specify the size of the scrollable content area.</li>
<li>指定滚动内容区域的尺寸</li>
<li>Provide attribute objects for the cells and views that make up your layout so that the collection view can position each cell and view.</li>
<li>为组成你的布局的单元格和视图提供属性对象，这样集合视图就可以定位每个单元格和视图。</li>
</ul>
<p>Although you can create a functional layout object that implements just the core methods, your layout is likely to be more engaging if you implement several of the optional methods as well.<br>尽管你可以创建一个功能性(functional)布局对象来只实现核心方法，但是如果你也实现几个可选方法可能会让你的布局更加吸引人(engaging).<br>The layout object uses information provided by its data source to create the collection view’s layout. Your layout communicates with the data source by calling methods on the collectionView propery, which is accessible in all of the layout’s methods. Keep in mind what your collection view knows and doesn’t know during the layout process. Because the layout process is under way, the collection view cannot track the layout or positioning of views. So even though the layout object will not restrict you from calling any of the collection view’s methods, refrain from relying on the collection view for anything other than the data necessary to compute your layout.<br>布局对象使用其数据源提供的信息来创建集合视图(collection view)的布局。布局通过在collectionView 特性上调用各种方法来跟数据源交流，collectionView 特性在所有布局方法中都是可访问的。 请记住在布局进程中集合视图知道什么，不知道什么。因为在布局进程运行时，集合视图不能监控布局和视图的位置。因此，即使布局对象不会限制你调用任何集合视图的方法，但是对于计算你的布局来说多信赖数据而不是集合视图的其它任何东西是很有必要的。</p>
<p>Understanding the Core Layout Process<br>1、理解核心布局进程<br>The collection view works directly with your custom layout object to manage the overall layout process. When the collection view determines that it needs layout information, it asks your layout object to provide it. For example, the collection view asks for layout information when it is first displayed or is resized. You can also tell the collection view to update its layout explicitly by calling the invalidateLayout method of the layout object. That method throws away the existing layout information and forces the layout object to generate new layout information.<br>集合视图直接和你的自定义布局对象一起工作来管理整个布局进程。 当集合视图确定它需要布局信息时，它请求你的布局对象提供。 比如，集合视图在它第一次被显示或者重新定义尺寸时将请求布局信息。 你还可以通过调用布局对象的invalidateLayout 方法来明确地告诉集合视图更新其布局。 该方法丢弃已经存在的布局信息并且强制布局对象生成新的布局信息。<br>Note: Be careful not to confuse the layout object’s invalidateLayout method with the collection view’s reloadData method. Calling the invalidateLayoutmethod does not necessarily cause the collection view to throw out its existing cells and subviews. Rather, it forces the layout object to recompute all of its layout attributes as is necessary when moving and adding or deleting items. If data within the data source has changed, the reloadData method is appropriate. Regardless of how you initiate a layout update, the actual layout process is the same.<br> 注意：小心别弄混了布局对象的invalidateLayout 方法和 集合视图的reloadData 方法。 调用invalidateLayout 方法并不会导致集合视图丢弃已经存在的单元格和子视图，而是迫使布局对象在移动和添加或删除数据项时根据需要重新计算其布局属性。 如果数据源里的数据发生改变，调用reloadData方法是正确的。 不管你如果初始化一个布局更新，真实的布局进程是一样的。<br>During the layout process, the collection view calls specific methods of your layout object. These methods are your chance to calculate the position of items and to provide the collection view with the primary information it needs. Other methods may be called, too, but these methods are always called during the layout process in the following order:<br>在布局过程期间，集合视图调用布局对象的指定方法。 这些方法就是你计算数据项的位置和提供带有所需的主要信息的集合视图的机会。 其它方法也有可能被调用，但是这些方法总是以在布局过程中以以下顺序被调用。</p>
<ul>
<li>Use the prepareLayout method to perform the up-front calculations needed to provide layout information.</li>
<li><p>使用 prepareLayout 方法来执行提供布局信息所需的各种前期计算。</p>
</li>
<li><p>Use the collectionViewContentSize method to return the overall size of the entire content area based on your initial calculations.</p>
</li>
<li><p>使用collectionViewContentSize 方法来返回基于你的初始计算的整个内容区的尺寸。</p>
</li>
<li><p>Use the layoutAttributesForElementsInRect: method to return the attributes for cells and views that are in the specified rectangle.</p>
</li>
<li>使用layoutAttributesForElementsInRect: 方法来返回指定矩形中的单元格和视图的属性。</li>
</ul>
<p>Figure 5-1 illustrates how you can use the preceding methods to generate your layout information.<br>图5-1 演示了你可以如何使用前面的方法来生成你的布局信息<br>Figure 5-1  Laying out your custom content<br>图5-1 布局你的自定义内容<br>The prepareLayout method is your opportunity to perform whatever calculations are needed to determine the position of the cells and views in the layout. At a minimum, you should compute enough information in this method to be able to return the overall size of the content area, which you return to the collection view in step 2.<br>prepareLayout 方法是你执行用来决定布局中单元格和视图的位置所需要的任何计算的好机会。 至少，你应该在该方法中计算足够的信息使其能返回内容区的整个尺寸，该尺寸返回到步骤2中的集合视图。</p>
<p>The collection view uses the content size to configure its scroll view appropriately. For instance, if your computed content size expands past the bounds of the current device’s screen both vertically and horizontally, the scroll view adjusts to allow scrolling in both directions simultaneously. Unlike theUICollectionViewFlowLayout, it does not by default adjust the layout of content to scroll in only one direction.<br>集合视图使用内容尺寸来正确地配置其滚动视图。 例如，如果你计算后的内容尺寸宽度和高度超出当前设备的屏幕边界，滚动视图将同时开始两个方向上的滚动。 不像UICollectionViewFlowLayout, 它默认不调整布局的内容,只在一个方向上滚动。<br>Based on the current scroll position, the collection view then calls your layoutAttributesForElementsInRect: method to ask for the attributes of the cells and views in a specific rectangle, which may or may not be the same as the visible rectangle. After returning that information, the core layout process is effectively complete.<br>根据当前的滚动位置，集合视图然后调用layoutAttributesForElementsInRect: 方法来请求指定矩形内的单元格的属性和视图，它们或许跟可见矩形一样，或许不一样。 返回那个信息之后，核心布局过程就有效地完成了。<br>After layout finishes, the attributes of your cells and views remain the same until you or the collection view invalidates the layout. Calling the invalidateLayoutmethod of your layout object causes the layout process to begin again, starting with a new call to the prepareLayout method. The collection view can also invalidate your layout automatically during scrolling. If the user scrolls its content, the collection view calls the layout object’sshouldInvalidateLayoutForBoundsChange: method and invalidates the layout if that method returns YES.<br>布局完成后，单元格和视图的属性保持不变直到你或者集合视图无效化布局。 调用布局对象的invalidateLayout 方法导致布局进程再次开始，以调用一个新的prepareLayout方法开始。集合视图还能在滚动期间自动无效化你的布局。 如果用户滚动其内容，集合视图调用布局对象的shouldInvalidateLayoutForBoundsChange: 方法，并在该方法返回YES之后无效化布局。<br>Note: It is useful to remember that calling the invalidateLayout method does not begin the layout update process immediately. The method merely marks the layout as being inconsistent with the data and in need of being updated. During the next view update cycle, the collection view checks to see whether its layout is dirty and updates it if it is. In fact, you can call the invalidateLayout method multiple times in quick succession without triggering an immediate layout update each time.<br>注意：调用invalidateLayout 方法并不会立即开始布局更新进程 。 该方法仅仅只是标记了当前数据和需要被更新的数据是不一样的。 在下个视图更新周期期间，集合视图检查其布局是否有变动(dirty)，如果是则更新它。 实际上，你可以多次快速连续的调用invalidateLayout方法，而不用每次都触发一个即时布局更新。</p>
<p>Creating Layout Attributes<br>2、创建布局属性<br>The attributes objects that your layout is responsible for are instances of the UICollectionViewLayoutAttributes class. These instances can be created in a variety of different methods in your app. When your app is not dealing with thousands of items, it makes sense to create these instances while preparing the layout, because the layout information can be cached and referenced rather than computed on the fly. If the costs of computing all the attributes up front outweighs the benefits of caching in your app, it is just as easy to create attributes in the moment when they are requested.<br>你的布局负责的属性对象都是 UICollectionViewLayoutAttributes 类的实例。 这些实例可以在应用程序里以一系列不同的方法创建。 当你的应用程序不处理成千上万条数据项时，在准备布局期间创建这些实例是有意义的，因为布局信息可以被缓存和引用，而不是飞快地计算。如果计算所有前期属性所花费的代价比缓存在应用程序中有价值，则只需要在它们被请求时创建属性。<br>Regardless, when creating new instances of the UICollectionViewLayoutAttributes class, use one of the following class methods:<br>无论如何，当创建UICollectionViewLayoutAttributes 类的新实例时，使用一个以下类方法：</p>
<ul>
<li>layoutAttributesForCellWithIndexPath:</li>
<li>layoutAttributesForSupplementaryViewOfKind:withIndexPath:</li>
<li>layoutAttributesForDecorationViewOfKind:withIndexPath:</li>
</ul>
<p>You must use the correct class method based on the type of the view being displayed because the collection view uses that information to request the appropriate type of view from the data source object. Using the incorrect method causes the collection view to create the wrong views in the wrong places and your layout does not appear as intended.<br>你必须根据视图的类型选择正确的类方法，因为集合视图使用那个信息从数据源对象请求正确的视图类型。使用不正确的方法会导致集合视图在错误的地方创建错误的视图，你的布局将不如预期的样子显示。<br>After creating each attributes object, set the relevant attributes for the corresponding view. At a minimum, set the size and position of the view in the layout. In cases where the views of your layout overlap, assign a value to the zIndex property to ensure a consistent ordering of the overlapping views. Other properties let you control the visibility or appearance of the cell or view and can be changed as needed. If the standard attributes class does not suit your app’s needs, you can subclass and expand it to store other information about each view. When subclassing layout attributes, it’s required that you implement the isEqual: method for comparing your custom attributes because the collection view uses this method for some of its operations.<br>创建完每个属性对象之后，为相应的视图设置相关的属性。至少设置视图在布局中的尺寸和位置。 当布局中的视图有重叠的情况时，给 zIndex 特性分配一个值来确保重叠视图的顺序。 其它特性可以让你根据需要控制单元格和视图的可视性和外观。如果标准属性类不符合你的需求，你可以子类化它并扩展它来存储每个视图的其它信息。 当你子类化布局属性时，它要求你实现isEqual:方法来比较自定义属性，因为集合视图在一些操作中将使用该方法。<br>For more information about layout attributes, see UICollectionViewLayoutAttributes Class Reference.<br>关于布局属性的更多信息，请看UICollectionViewLayoutAttributes Class Reference.</p>
<p>Preparing the Layout<br>3、为布局做准备<br>At the beginning of the layout cycle, the layout object calls prepareLayout before beginning the layout process. This method is your chance to calculate information that later informs your layout. The prepareLayout method is not required to implement a custom layout but is provided as an opportunity to make initial calculations if necessary. After this method is called, your layout must have enough information to calculate the collection view’s content size, the next step in the layout process. The information, however, can range from this minimum requirement to creating and storing all the layout attributes objects your layout will use. Use of the prepareLayout method is subject to the infrastructure of your app and to what makes sense to compute up front versus what to compute upon request. For an example of what the prepareLayout method might look like, see “Preparing the Layout.”<br>在布局周期的开始，布局对象在开始布局进程之前，调用prepareLayout 方法。 该方法可以用来计算稍候通知布局的各种信息。 prepareLayout 方法不要求实现一个自定义布局，但是提供了一个机会来做一些必要的初始化计算。 调用完该方法之后，你的布局必须有足够的信息来计算集合视图的视图内容尺寸，布局进程的下一步。 然而，信息可以从最低要求到创建并存储布局将使用的所有布局属性对象。使用 prepareLayout 方法受应用程序基础架构，以及什么对计算前面有意义与什么对计算超出要求等影响(Use of the prepareLayout method is subject to the infrastructure of your app and to what makes sense to compute up front versus what to compute upon request.)。关于prepareLayout方法的例子，请看 “Preparing the Layout.”</p>
<p>Providing Layout Attributes for Items in a Given Rectangle<br>4、给一个给定矩形中的数据项提供布局属性<br>During the final step of the layout process, the collection view calls your layout object’s layoutAttributesForElementsInRect: method. The purpose of this method is to provide layout attributes for every cell and every supplementary or decoration view that intersects the specified rectangle. For a large scrollable content area, the collection view may just ask for the attributes of items in the portion of that content area that is currently visible. In Figure 5-2, the currently visible content that your layout object needs to create attribute objects for is cells 6 through 20 along with the second header view. You must be prepared to provide layout attributes for any portion of your collection view content area. Such attributes might be used to facilitate animations for inserted or deleted items.<br>在布局进程的最后一步中，集合视图调用你的布局对象的 layoutAttributesForElementsInRect: 方法。 该方法的目的是为在制定矩形中交互的每个单元格和每个补充或装饰视图提供布局属性。 对于一个大滚动内容区，集合视图可能只请求当前可见内容区部分的数据项属性。 图5-2中， 你的布局对象需要为单元格6-20以及第二个头视图创建属性对象，它们是当前的可见内容。你必须准备好提供集合视图内容区任何部分的布局属性。 这些属性可能被用于促进插入或删除数据项的动画。<br>Figure 5-2  Laying out only the visible views<br>图5-2 只布局可见视图</p>
<p>Because the layoutAttributesForElementsInRect method is called after your layout object’s prepareLayout method, you should already have most of the information you need in order to return or create the required attributes. The implementation of your layoutAttributesForElementsInRect method follows these steps:<br>因为layoutAttributesForElementsInRect: 方法在布局对象的prepareLayout 方法之后调用，你应该已经有大多数你需要的信息以便返回或创建被请求的各种属性。 layoutAttributesForElementsInRect: 方法的实现遵循以下步骤:</p>
<ul>
<li>Iterate over the data generated by the prepareLayout method to either access cached attributes or create new ones.</li>
<li><p>迭代由prepareLayout 方法生成的数据，用来访问被缓存属性或创建新属性。</p>
</li>
<li><p>Check the frame of each item to see whether it intersects the rectangle passed to the layoutAttributesForElementsInRect: method.</p>
</li>
<li><p>检查每个数据项的框架(frame)，查看它是否跟传递给 layoutAttributesForElementsInRect: 方法的矩形相交互。</p>
</li>
<li><p>For each intersecting item, add a corresponding UICollectionViewLayoutAttributes object to an array.</p>
</li>
<li><p>对于每个交互的数据项，添加一个相应的 UICollectionViewLayout 属性对象到一个数组。</p>
</li>
<li><p>Return the array of layout attributes to the collection view.</p>
</li>
<li>把布局属性的数组返回给集合视图。</li>
</ul>
<p>Depending on how you manage your layout information, you might create UICollectionViewLayoutAttributes objects in your prepareLayout method or wait and do it in your layoutAttributesForElementsInRect: method. While forming an implementation that matches the needs of your application, keep in mind the benefits of caching layout information. Computing new layout attributes repeatedly for cells is an expensive operation, one that can have noticeably detrimental effects on your app’s performance. That said, when the amount of items your collection view manages is large, it may make more sense (for performance) to create the layout attributes when requested. It’s simply a matter of figuring out which strategy makes most sense for your app.<br>根据你如何管理你的布局信息，你可以在你的prepareLayout方法或者等待在layoutAttributesForElementsInRect: 方法中创建UICollectionViewLayoutAttributes 对象。当你构成(forming)一个符合你的应用程序的需要的实现时，牢记缓存布局信息的好处。为单元格重复计算新的布局属性是一个昂贵的操作，它对你的应用程序性能明显不利。就是说，当你的结合视图管理的数据项总量巨大时，在请求时创建布局属性对性能来说更有利。这是一个找出哪些策略最最适合应用程序的简单问题。<br>Note: Layout objects also need to be able to provide layout attributes on demand for individual items. The collection view might request that information outside of the normal layout process for several reasons, including to create appropriate animations. For more information about providing layout attributes on demand, see “Providing Layout Attributes On Demand.”<br> 注意：布局对象还需要能够为独立数据项需求提供布局属性。 集合视图可能处于多种原因请求在正常布局进程外的信息，包括创建正确的动画。 关于根据需求提供布局属性的更多信息，请看“Providing Layout Attributes On Demand.”<br>For a specific example of how one might implement layoutAttributesForElementsInRect:, see “Providing Layout Attributes.”<br>关于如何实现layoutAttributesForElementsRect:方法的一种可能实现，请看“Providing Layout Attributes.”</p>
<p>Providing Layout Attributes On Demand<br>5、根据需要提供布局属性<br>The collection view periodically asks your layout object to provide attributes for individual items outside of the formal layout process. For example, the collection view asks for this information when configuring insertion and deletion animations for an item. Your layout object must be prepared to provide the layout attributes for each cell, supplementary view, and decoration view it supports. You do this by overriding the following methods:<br>集合视图周期性的请求你的布局对象为正式布局进程意外的独立数据项提供各种属性。 比如，。集合视图在为一个数据项配置插入和删除动画时会请求该信息。 你的布局对象必须准备好为每个单元格，辅助视图以及它支持的装饰视图提供各种布局属性。 你可以通过重写以下方法实现:</p>
<ul>
<li>layoutAttributesForItemAtIndexPath:</li>
<li>layoutAttributesForSupplementaryViewOfKind:atIndexPath:</li>
<li>layoutAttributesForDecorationViewOfKind:atIndexPath:</li>
</ul>
<p>Your implementation of these methods should retrieve the current layout attributes for the given cell or view. Every custom layout object is expected to implement the layoutAttributesForItemAtIndexPath: method. If your layout does not contain any supplementary views, you do not need to override thelayoutAttributesForSupplementaryViewOfKind:atIndexPath: method. Similarly, if it does not contain decoration views, you do not need to override thelayoutAttributesForDecorationViewOfKind:atIndexPath: method. When returning attributes, you should not update the layout attributes. If you need to change the layout information, invalidate the layout object and let it update that data during a subsequent layout cycle.<br>这些方法的实现应该恢复给定单元格或视图的当前布局属性。每个自定义布局对象都期待实现layoutAttributesForItemAtIndexPath:方法。 如果你的布局不包含任何辅助视图，你就不需要重写layoutAttributesForSupplementaryViewOfKind:atIndexPath:layoutAttributesForItemAtIndexPath: 方法。 如果你的布局不包含任何装饰视图，你就不需要冲昂鞋layoutAttributesForDecorationViewOfKind:atIndexPath: 方法。 当返回属性时，你不应该更新布局属性。 如果你需要改变布局信息，无效化布局对象并让它在一个子序列布局周期里更新数据。</p>
<p>Connecting Your Custom Layout for Use<br>6、连接你的自定义布局以备用<br>There are two ways to link your custom layout to the collection view: programmatically or through storyboards. The collection view links to its layout through a writable property, collectionViewLayout. To set the layout to your custom implementation, set your collection view’s layout property to an instance of your custom layout object. Listing 5-1 shows the line of code needed.<br>有两种方法可以把你的自定义布局连接到集合视图： 通过程序或通过故事板。 集合视图通过一个可写特性连接到其布局上，即：collectionViewLayout。 要想设置布局到你的自定义实现，设置你的集合视图的布局特性到你的自定义布局对象的实例上。列表5-1 显示了需要的代码行。</p>
<p>Listing 5-1  Linking your custom layout<br>列表 5-1 连接你的自定义布局<br>self.collectionView.collectionViewLayout = [[MyCustomLayout alloc] init];<br>Otherwise, from your storyboard, open the Document Outline panel and select your collection view (it is listed in the drop-down menu for your controller). With the collection view selected, open the Attributes inspector in the Utilities pane, and underneath the section labeled Collection View change the Layout option from Flow to Custom. The option beneath it changes from Scroll Direction to Class, and you can now select your custom layout class.<br>或者，从你的故事板，打开Document Outline 面板，选择你的集合视图(它在你的控制器的下拉菜单中). 选择好之后，打开Utilities 面板中的Attributes inspector, 并且把以下标记集合视图的选项从Flow改为Custom。 它下面(beneath)的选项从从滚动方向变为类，你现在就可以选择你的自定义布局类了。</p>
<p>Making Your Custom Layouts More Engaging<br>二、让你的自定义布局变得更加有吸引力<br>Providing layout attributes for each cell and view during the layout process is required, but there are other behaviors that can improve the user experience with your custom layout. Implementing these behaviors is optional but recommended.<br>除了可以在布局进程期间请求时为每个单元格和视图提供各种布局属性，还有其他行为可以为你的自定义布局提高用户体验。这些行为的实现是可选的，但是建议你实现。</p>
<p>Elevating Content Through Supplementary Views<br>1、通过辅助视图提升内容<br>Supplementary views are separate from the collection view’s cells and have their own set of layout attributes. Like cells, these views are provided by the data source object, but their purpose is to enhance the main content of your app. For example, the UICollectionViewFlowLayout uses supplementary views for section headers and footers. Another app could use supplementary views to give each cell its own text label to display information about that cell. Like collection view cells, supplementary views undergo a recycling process to optimize the amount of resources used by the collection view. Therefore, all supplementary views used in your app should be subclassed from the UICollectionReusableView class.<br>辅助视图是跟集合视图的单元格分离并由它们自己的布局属性集。 就像单元格，这些视图由数据源对象提供，但是它们的目的是增强应用程序的主要内容。 比如，UICollectionViewFlowLayout 使用辅助视图来做区头(section headers)和区尾。 另一个应用程序可能使用辅助视图来给每个单元格(cell)设置一个自己的文本标签来显现该单元格的内容。 就像集合视图单元格，辅助视图通过一个再循环(recycling)进程来优化集合视图使用的资源总量。 因此，应用程序中使用的所有辅助视图都应该是 UICollectionReusableView 类的子类。<br>The steps for adding supplementary views to your layouts are as follows:</p>
<p>添加辅助视图到你的布局需要完成以下步骤：<br>-<strong>sdfsfd</strong></p>
<p>The process for creating the attributes objects for supplementary views in your custom layout is nearly identical to the process for cells, but differs in that a custom layout can have multiple types of supplementary views but is restricted to one type of cell. This is because supplementary views are meant to enhance the main content and are therefore separate from it. There are many ways in which an app’s content can be supplemented, and so each of the supplementary view’s methods specifies which kind of view is being addressed to distinguish it from the others and allow your layout to compute its attributes correctly based on its type. When registering a supplementary view for use, the string you provide is used by the layout object to distinguish the view from others. For an example of incorporating supplementary views into your custom layout, see “Incorporating Supplementary Views.”<br>为自定义布局辅助视图创建属性对象的过程和为单元格创建属性对象的过程几乎一样，除了一个自定义布局可以有多个类型的辅助属性，但是只能有一种类型的单元格。 这是因为辅助视图是为了提升主要内容，因此它被从布局中分离出来。在很多方法里面可以辅助说明应用程序的内容，每个辅助视图的方法都可以指定视图的处理类型，用它来区别别的视图，并且可以让你的布局根据该类型来正确地计算它的属性。当泽侧一个辅助视图时，你提供的字符串是布局用来跟其它视图区别的标记。 关于给你的自定义布局添加辅助视图的例子，请看“Incorporating Supplementary Views.”</p>
<p>Including Decoration Views in Your Custom Layouts<br>2、让你的自定义布局包含装饰视图<br>Decoration views are visual adornments that enhance the appearance of your collection view layouts. Unlike cells and supplementary views, decoration views provide visual content only and are thus independent of the data source. You can use them to provide custom backgrounds, fill in the spaces around cells, or even obscure cells if you want. Decoration views are defined and managed solely by the layout object and do not interact with the collection view’s data source object.<br>装饰视图是用来增强集合视图布局外观的可视化装饰。不像单元格和辅助视图，装饰视图只提供可视化内容，因此它不依赖数据源。你可以使用它们来提供自定义背景，填充单元格边上的空白，或者如果你想你甚至可以隐藏(obscure)单元格。 装饰视图仅由布局对象定义和管理，并不跟集合视图的数据源发生交互。<br>To add decoration views to your layouts, do the following:<br>要想给布局添加装饰视图，你需要完成以下步骤：</p>
<p>The creation process for decoration views is different from the process for cells and supplementary views. Registering a class or nib file is all you have to do to ensure that decoration views are created when they are needed. Because they are purely visual, decoration views are not expected to need any configuration beyond what is already done in the provided nib file or by the object’s initWithFrame: method. For this reason, when a decoration view is needed, the collection view creates it for you and applies the attributes provided by the layout object. Any decoration views should still be a subclass of UICollectionReusableViewbecause the layout object employs a recycling mechanism for its decoration views.<br>装饰视图的创建过程和创建单元格和辅助视图的过程不一样。 你只需要在需要时为装饰视图注册一个类或nib文件。 因为它们是纯粹的视觉，装饰视图不需要在提供的nib文件或对象的initWithFrame: 方法中已经提供的任何配置。 因此，当需要一个装饰视图时，集合视图为你创建并由布局对象提供各种属性。 任何装饰视图也都应该是 UICollectionReusableView 类的子类，因为布局对象为它的装饰视图采用了一套回收机制。<br>Note: When creating the attributes for your decoration views, don’t forget to take into account the zIndex property. You can use the zIndex attribute to layer your decoration views behind (or, if you prefer, in front of) the displayed cells and supplementary views.<br>注意：当你为装饰视图创建各种属性时，不要忘记考虑zIndex特性。 你可以使用zIndex 属性让装饰视图置于显示的单元格和辅助视图后面，或者前面。</p>
<p>Making Insertion and Deletion Animations More Interesting<br>3、让插入和删除动画更加有趣<br>Inserting and deleting cells and views poses an interesting challenge during layout. Inserting a cell can cause the layout for other cells and views to change. Even though the layout object knows how to animate existing cells and views from their current locations to new locations, it has no current location for the cell being inserted. Rather than insert the new cell without animations, the collection view asks the layout object to provide a set of initial attributes to use for the animation. Similarly, when a cell is deleted, the collection view asks the layout object to provide a set of final attributes to use for the endpoint of any animations.<br>在布局过程中插入和删除单元格和视图构成了一个有趣的挑战。 插入一个单元格可以导致布局上的其它单元格和视图发生改变。 尽管布局对象了解如何动画已经存在的单元格和视图从当前位置到新的位置，但是它没有刚被插入的单元格的位置。 集合视图请求布局对象提供一组初始属性供动画使用，而不是不用动画插入新单元格。 相似地，当一个单元格被删除时，集合视图请求布局对象提供一组结束属性用于任何动画的结束。<br>To understand how initial attributes work, it helps to see an example. The starting layout (Figure 5-3) shows a collection view that initially contains only three cells. When a new cell is inserted, the collection view asks the layout object to provide initial attributes for the cell being inserted. In this case, the layout object sets the initial position of the cell to the middle of the collection view and sets its alpha value to 0 to hide it. During the animations, this new cell appears to fade in and move from the center of the collection view to its final position in the lower-right corner.<br>要想理解初始属性如何工作，看个例子会有帮助。 图5-3中开始布局显示了一个最初包含三个单元格的集合视图。 当一个新单元格被插入时，集合视图请求布局对象为即将插入的单元格提供初始属性。在这种情况下，布局对象把单元格的初始位置设置为集合视图的中心，并且设置它的透明纸(alpha value)为0，把它隐藏。 在动画过程中，该新单元格开始淡入(fade in)并从集合视图的中心点移动到它的最终位置-即屏幕的右下角。<br>Figure 5-3  Specifying the initial attributes for an item appearing onscreen<br>图5-3 为一个出现在屏幕上的数据项指定初始属性</p>
<p>Listing 5-2 shows the code you might use to specify the initial attributes for the inserted cell from Figure 5-3. This method sets the position of the cell to the center of the collection view and makes it transparent. The layout object would then provide the final position and alpha for the cell as part of the normal layout process.<br>列表5-2 显示了实现图5-3所需要使用的代码。 该方法把单元格的位置设置为集合视图的中心，并且把它设置为透明。 然后作为正常布局进程的一部分，布局对象将为单元格提供最终位置和透明度。</p>
<p>Listing 5-2  Specifying the initial attributes for an inserted cell<br>列表 5-2 为一个插入单元格指定初始属性<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">- (<span class="built_in">UICollectionViewLayoutAttributes</span> *)initialLayoutAttributesForAppearingItemAtIndexPath:(<span class="built_in">NSIndexPath</span> *)itemIndexPath &#123;</div><div class="line">   <span class="built_in">UICollectionViewLayoutAttributes</span>* attributes = [<span class="keyword">self</span> layoutAttributesForItemAtIndexPath:itemIndexPath];</div><div class="line">   attributes.alpha = <span class="number">0.0</span>;</div><div class="line"> </div><div class="line">   <span class="built_in">CGSize</span> size = [<span class="keyword">self</span> collectionView].frame.size;</div><div class="line">   attributes.center = <span class="built_in">CGPointMake</span>(size.width / <span class="number">2.0</span>, size.height / <span class="number">2.0</span>);</div><div class="line">   <span class="keyword">return</span> attributes;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>Note: Listing 5-2 would animate all cells when one is inserted, so the three cells that were already present before the fourth was inserted would also pop out from the center of the collection view. To animate only the cell being inserted, check to see if the index path of the item matches the index path of an item passed to the prepareForCollectionViewUpdates: method and only perform the animation if a match is found. Otherwise, return the attributes returned by calling the super method of initialLayoutAttributesForAppearingItemAtIndexPath:.<br>注意:当一个单元格被插入时，列表5-2 可能动画所有单元格，因此已经被呈现的三个单元格也可能从集合视图的中心弹出。要想只动画被插入的单元格，检查数据项的索引路径是否跟传递到prepareForCollectionViewUpdates: 方法的索引路径相匹配，并且只在匹配成功时执行动画。 另外，调用initialLayoutAttributesForAppearingItemAtIndexPath:方法的super方法来返回返回的属性。</p>
<p>The process for handling deletions is identical to the process for insertions except that you specify the final attributes instead of the initial attributes. From the previous example, if you used the same attributes that you used when inserting the cell, deleting the cell would cause it to fade out while moving to the center of the collection view. There are six methods available to you within the UICollectionViewLayout class—two separate methods (for initial and final attributes) for items, supplementary views, and decoration views.<br>处理删除的过程和处理插入的过程是一样的，除了你需要指定最终属性而不是初始属性。 从前一个例子，如果你使用跟插入单元格时相同的属性，删除单元格将导致单元格移动到集合视图中心过程中淡出(fade out)。 在UICollectionViewLayout 类中有6种方法你可以使用–两种分离的方法(用于初始和最终属性)用于数据项，辅助视图，以及装饰视图。</p>
<p>Improving the Scrolling Experience of Your Layout<br>4、增进布局的滚动体验<br>Your custom layout object can influence the scrolling behavior of the collection view to create a better user experience. When scrolling-related touch events end, the scroll view determines the final resting place of the scrolling content based on the current speed and deceleration rate in effect. When the collection view knows that location, it asks its layout object if the location should be modified by calling itstargetContentOffsetForProposedContentOffset:withScrollingVelocity: method. Because it calls this method while the underlying content is still moving, your custom layout can affect the final resting point of the scrolling content.<br>自定义布局对象可以影响集合视图的滚动行为以创建一个更好的用户体验。 当滚动相关的触摸事件结束时，滚动视图根据当前的速度以及影响的减速率(deceleration rate)决定滚动内容的最终剩余位置。当集合视图知道那个位置，它询问它的布局对象是否应该调用targetContentOffsetForProposedContentOffset:withScrollingVelocity: 方法来修改该位置。因为在底层内容还在移动的过程中调用该方法，所以自定义布局可以影响滚动内容的最终剩余点。<br>Figure 5-4 demonstrates how you might use your layout object to change the scrolling behavior of the collection view. Suppose the collection view offset starts at (0, 0) and the user swipes left. The collection view computes where the scrolling would naturally stop and provides that value as the “proposed” content offset value. Your layout object might change the proposed value to ensure that when scrolling stops, an item is centered precisely in the visible bounds of the collection view. This new value becomes the target content offset and is what you return from yourtargetContentOffsetForProposedContentOffset:withScrollingVelocity: method.<br>图5-4 演示了你如何使用布局对象来改变集合视图的滚动行为。 假设集合视图的偏移量开始于(0,0)，用户向左轻扫屏幕。 集合视图计算滚动应该在哪自然地停止并把该值作为”建议的”内容偏移量值提供给视图。你的布局对象可能改变该建议值，以确保滚动停止时，一个项目正是在集合视图的可见边界居中。 这个新值变成目标内容偏移量，正是你从targetContentOffsetForProposedContentOffset:withScrollingVelocity:方法中返回的值。<br>Figure 5-4  Changing the proposed content offset to a more appropriate value<br>图 5-4 更改建议内容偏移量到一个更恰当的值</p>
<p>Tips for Implementing Your Custom Layouts<br>三、实现自定义布局的小提示<br>Here are some tips and suggestions for implementing your custom layout objects:<br>以下是一些实现自定义布局对象的提示和建议</p>
<ul>
<li>Consider using the prepareLayout method to create and store the UICollectionViewLayoutAttributes objects you need for later. The collection view is going to ask for layout attribute objects at some point, so in some cases it makes sense to create and store them up front. This is especially true if you have a relatively small number of items (several hundred) or the actual layout attributes for those items change infrequently.<br>考虑使用prepareLayout方法来创建并存储你以后需要的UICollectionViewLayoutAttributes 对象。 集合视图将会在一些点请求布局属性对象，所以在一些情况下最好提前创建和存储它们。 这点在你有一个相对少量的数据项(几百)或者那些数据项的实际布局属性不经常改变时尤其正确。</li>
</ul>
<p>If your layout needs to manage thousands of items, though, you need to weigh the benefits of caching versus recomputing. For variable-size items whose layout changes infrequently, caching generally eliminates the need to recompute complex layout information regularly. For large numbers of fixed-size items, it may just be simpler to compute attributes on demand. And for items whose attributes change frequently, you might be recomputing all the time anyway so caching may just take up extra space in memory.<br>如果你的布局需要管理成千上万的数据项，你就需要权衡缓存和重复计算之间的好处。 对于数量可变布局不经常改变的数据项，缓存通常不需要定期重复计算复杂的布局信息。 对于固定数量的大数量数据项，在需要的时候计算属性更简便。 对于属性经常改变的数据项，你或许需要总是重复计算，因此缓存可能只是占用内存的额外空间。</p>
<ul>
<li><p>Avoid subclassing UICollectionView. The collection view has little or no appearance of its own. Instead, it pulls all of its views from your data source object and all of the layout-related information from the layout object. If you are trying to lay out items in three dimensions, the proper way to do it is to implement a custom layout that sets the 3D transform of each cell and view appropriately.</p>
</li>
<li><p>避免子类化UICollectionView。 集合视图只有一点或没有它自己的外观。 相反，它从你的数据源拉取所有它的视图，并且从布局对象拉取布局相关的所有信息。 如果你想尝试以3D方式布局数据项，正确的方法是实现一个自定义布局，在该布局上为每个单元格设置正确地3D变换和视图。</p>
</li>
</ul>
<ul>
<li>决不要从自定义布局对象的layoutAttributesForElementsInRect:中调用UICollectionView的visibleCells方法。 集合视图对数据项在哪一无所知，除了布局对象告诉它的信息之外。因此请求可视单元格仅仅是把请求转发给你的布局对象。</li>
</ul>
<p>你的布局对象应该总是知道在内容区的数据项的位置，并且应该能够在任何时候返回那些数据项的属性。 在大多数情况下，它应该自己做到这点。 在极少数情况下，布局对象可能依赖数据源中的信息来定位数据项。 比如，一个在地图上显示数据项的布局可能从数据源那取回每个数据项的地图位置。</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/06/22/my-new-post/" rel="next" title="应用的生命周期(The App Life Cycle)">
                <i class="fa fa-chevron-left"></i> 应用的生命周期(The App Life Cycle)
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/06/22/g/" rel="prev" title="g">
                g <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Inhaltsverzeichnis
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Übersicht
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="David" />
          <p class="site-author-name" itemprop="name">David</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">Artikel</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">Tags</span>
              
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#About-iOS-Collection-Views（关于Collection-Views）"><span class="nav-number">1.</span> <span class="nav-text">About iOS Collection Views（关于Collection Views）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#At-a-Glance-概览"><span class="nav-number">1.1.</span> <span class="nav-text">At a Glance(概览)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#A-Collection-View-Manages-the-Visual-Presentation-of-Data-Driven-Views（管理驱动视图的可视化数据呈现）"><span class="nav-number">1.2.</span> <span class="nav-text">A Collection View Manages the Visual Presentation of Data-Driven Views（管理驱动视图的可视化数据呈现）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#The-Flow-Layout-Supports-Grids-and-Other-Line-Oriented-Presentations-流式布局支持网格和其它面向线条的表现方式"><span class="nav-number">1.3.</span> <span class="nav-text">The Flow Layout Supports Grids and Other Line-Oriented Presentations(流式布局支持网格和其它面向线条的表现方式)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Gesture-Recognizers-Can-Be-Used-for-Cell-and-Layout-Manipulations-手势识别能用于单元-cell-和布局操作"><span class="nav-number">1.4.</span> <span class="nav-text">Gesture Recognizers Can Be Used for Cell and Layout Manipulations(手势识别能用于单元(cell)和布局操作)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Custom-Layouts-Let-You-Go-Beyond-Grids-自定义布局让你超越网格布局"><span class="nav-number">1.5.</span> <span class="nav-text">Custom Layouts Let You Go Beyond Grids(自定义布局让你超越网格布局)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Collection-View-Basics-Collection-View基础"><span class="nav-number">2.</span> <span class="nav-text">Collection View Basics(Collection View基础)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Collection-View-is-a-Collaboration-of-Objects-Collection-View-是一些对象的合作结果"><span class="nav-number">2.1.</span> <span class="nav-text">Collection View is a Collaboration of Objects(Collection View 是一些对象的合作结果)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Reusable-Views-Improve-Performance-复用视图提高性能"><span class="nav-number">2.2.</span> <span class="nav-text">Reusable Views Improve Performance(复用视图提高性能)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#The-Layout-Object-Controls-the-Visual-Presentation-布局对象管理可视化外形"><span class="nav-number">2.3.</span> <span class="nav-text">The Layout Object Controls the Visual Presentation(布局对象管理可视化外形)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Collection-Views-Initiate-Animations-Automatically-Collection-views自动初始化动画"><span class="nav-number">2.4.</span> <span class="nav-text">Collection Views Initiate Animations Automatically(Collection views自动初始化动画)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Designing-Your-Data-Source-and-Delegate-设计你的数据源和委托"><span class="nav-number">3.</span> <span class="nav-text">Designing Your Data Source and Delegate(设计你的数据源和委托)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#The-Data-Source-Manages-Your-Content-数据源管理内容"><span class="nav-number">3.1.</span> <span class="nav-text">The Data Source Manages Your Content(数据源管理内容)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Designing-Your-Data-Objects-设计你的数据对象"><span class="nav-number">3.2.</span> <span class="nav-text">Designing Your Data Objects(设计你的数据对象)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Telling-the-Collection-View-About-Your-Content-告诉Collection-View你的内容"><span class="nav-number">3.3.</span> <span class="nav-text">Telling the Collection View About Your Content(告诉Collection View你的内容)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Configuring-Cells-and-Supplementary-Views-配置单元格和补充视图"><span class="nav-number">3.4.</span> <span class="nav-text">Configuring Cells and Supplementary Views(配置单元格和补充视图)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Registering-Your-Cells-and-Supplementary-Views-注册你的单元格和补充视图"><span class="nav-number">3.5.</span> <span class="nav-text">Registering Your Cells and Supplementary Views(注册你的单元格和补充视图)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dequeueing-and-Configuring-Cells-and-Views-出队和配置单元格和视图"><span class="nav-number">3.6.</span> <span class="nav-text">Dequeueing and Configuring Cells and Views(出队和配置单元格和视图)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Inserting-Deleting-and-Moving-Sections-and-Items-插入，删除，以及移动Sections-和-Items"><span class="nav-number">3.7.</span> <span class="nav-text">Inserting, Deleting, and Moving Sections and Items(插入，删除，以及移动Sections 和 Items)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Managing-the-Visual-State-for-Selections-and-Highlights-管理选区和高亮显示的视觉状态"><span class="nav-number">3.8.</span> <span class="nav-text">Managing the Visual State for Selections and Highlights(管理选区和高亮显示的视觉状态)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Showing-the-Edit-Menu-for-a-Cell-为单元格显示编辑按钮"><span class="nav-number">3.9.</span> <span class="nav-text">Showing the Edit Menu for a Cell(为单元格显示编辑按钮)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Transition-Between-Layouts-布局间的过渡"><span class="nav-number">3.10.</span> <span class="nav-text">Transition Between Layouts(布局间的过渡)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Using-the-Flow-Layout-使用流式布局"><span class="nav-number">4.</span> <span class="nav-text">Using the Flow Layout(使用流式布局)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Customizing-the-Flow-Layout-Attributes-自定义流布局属性"><span class="nav-number">4.1.</span> <span class="nav-text">Customizing the Flow Layout Attributes(自定义流布局属性)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Specifying-the-Size-of-Items-in-the-Flow-Layout-在流布局里指定数据项的尺寸"><span class="nav-number">4.2.</span> <span class="nav-text">Specifying the Size of Items in the Flow Layout(在流布局里指定数据项的尺寸)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Specifying-the-Space-Between-Items-and-Lines-指定数据项之间，行之间的间隔"><span class="nav-number">4.3.</span> <span class="nav-text">Specifying the Space Between Items and Lines(指定数据项之间，行之间的间隔)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Using-Section-Insets-to-Tweak-the-Margins-of-Your-Content-使用Section-Insets来调整内容的边距"><span class="nav-number">4.4.</span> <span class="nav-text">Using Section Insets to Tweak the Margins of Your Content(使用Section Insets来调整内容的边距)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Knowing-When-to-Subclass-the-Flow-Layout-了解何时子类化流布局"><span class="nav-number">4.5.</span> <span class="nav-text">Knowing When to Subclass the Flow Layout(了解何时子类化流布局)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Incorporating-Gesture-Support-结合手势支持"><span class="nav-number">5.</span> <span class="nav-text">Incorporating Gesture Support(结合手势支持)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Using-a-Gesture-Recognizer-to-Modify-Layout-Information-使用手势识别来修改布局信息"><span class="nav-number">5.1.</span> <span class="nav-text">Using a Gesture Recognizer to Modify Layout Information(使用手势识别来修改布局信息)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Working-with-the-Default-Gesture-Recognizers-用默认手势识别工作"><span class="nav-number">5.2.</span> <span class="nav-text">Working with the Default Gesture Recognizers(用默认手势识别工作)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Manipulating-Cells-and-Views-操作Cells-和视图"><span class="nav-number">5.3.</span> <span class="nav-text">Manipulating Cells and Views(操作Cells 和视图)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Creating-Custom-Layouts"><span class="nav-number">6.</span> <span class="nav-text">Creating Custom Layouts</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">David</span>
</div>


<div class="powered-by">
  Erstellt mit  <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  

  

</body>
</html>
